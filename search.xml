<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-CO-P7</title>
      <link href="/2026/01/14/BUAA-CO-P7/"/>
      <url>/2026/01/14/BUAA-CO-P7/</url>
      
        <content type="html"><![CDATA[<h1 id="P7-用-Verilog-搭建-MIPS-微系统"><a href="#P7-用-Verilog-搭建-MIPS-微系统" class="headerlink" title="P7 - 用 Verilog 搭建 MIPS 微系统"></a>P7 - 用 Verilog 搭建 MIPS 微系统</h1><p>P7 的核心任务是设计一个支持 <strong>中断 (Interrupt)</strong> 和 <strong>异常 (Exception)</strong> 的 MIPS 微系统。<br>在 P6 流水线 CPU 的基础上，我们需要引入 <strong>CP0 协处理器</strong>、<strong>系统桥 (Bridge)</strong> 以及 <strong>定时器 (Timer)</strong>，并将单纯的“取指-执行”循环升级为“取指-执行-异常检测-处理”的复杂状态流。</p><h2 id="1-系统架构概览"><a href="#1-系统架构概览" class="headerlink" title="1. 系统架构概览"></a>1. 系统架构概览</h2><p>初次上手P7会感觉有点蒙，处理不好P6和P7之间的关系，简而言之<br>P7不再是孤立的 CPU，而是一个包含外设的 SoC (System on Chip) 原型。<br>顶层模块包含：</p><ul><li><strong>CPU</strong>：流水线处理器，新增异常支持，主体就是P6设计的组件+CP0协处理器，同时把IM和DM拿出CPU</li><li><strong>Bridge (系统桥)</strong>：连接 CPU 与外设的“路由器”。</li><li><strong>Timer0 &#x2F; Timer1</strong>：官方提供的定时器外设。</li></ul><h2 id="2-CPU-增量开发-Incremental-Design"><a href="#2-CPU-增量开发-Incremental-Design" class="headerlink" title="2. CPU 增量开发 (Incremental Design)"></a>2. CPU 增量开发 (Incremental Design)</h2><p>CPU 需要支持新指令 <code>mfc0</code>, <code>mtc0</code>, <code>syscall</code>, <code>eret</code>，并在硬件上实现异常检测与响应。</p><h3 id="2-1-CP0-协处理器-The-Brain-of-Exception"><a href="#2-1-CP0-协处理器-The-Brain-of-Exception" class="headerlink" title="2.1 CP0 协处理器 (The Brain of Exception)"></a>2.1 CP0 协处理器 (The Brain of Exception)</h3><p>CP0 是异常处理的核心，负责记录异常信息、屏蔽中断以及控制模式切换。为了保证异常处理的精确性并防止误操作外设，我将 CP0 放置在流水线的 <strong>M 级 (Memory Stage)</strong>。在M级对异常中断进行处理，<strong>既可以保证所有的异常都被处理，不会遗漏，也可以保证异常导致的写入错误可以被修复</strong></p><p><strong>核心寄存器定义</strong>：</p><table><thead><tr><th align="left">寄存器</th><th align="left">关键位域</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>SR</strong> (12)</td><td align="left"><code>IM[15:10]</code></td><td align="left">6 位中断屏蔽位，1 允许，0 禁止。</td></tr><tr><td align="left"></td><td align="left"><code>EXL[1]</code></td><td align="left">异常级标志。<strong>1 表示正在处理异常</strong>，此时强制屏蔽中断。</td></tr><tr><td align="left"></td><td align="left"><code>IE[0]</code></td><td align="left">全局中断使能。</td></tr><tr><td align="left"><strong>Cause</strong> (13)</td><td align="left"><code>BD[31]</code></td><td align="left"><strong>分支延迟槽标志</strong>。若异常发生于延迟槽指令，该位置 1。</td></tr><tr><td align="left"></td><td align="left"><code>IP[15:10]</code></td><td align="left">待决中断位，记录当前哪几个中断线有信号。</td></tr><tr><td align="left"></td><td align="left"><code>ExcCode[6:2]</code></td><td align="left">异常编码 (如 Int&#x3D;0, Syscall&#x3D;8, Ov&#x3D;12)。</td></tr><tr><td align="left"><strong>EPC</strong> (14)</td><td align="left">-</td><td align="left">记录异常返回地址 (Victim PC)。</td></tr></tbody></table><p><strong>异常判断逻辑</strong>：</p><ul><li><strong>外部中断</strong>：<code>IntReq = (|(HWInt &amp; IM)) &amp; IE &amp; ~EXL</code></li><li><strong>内部异常</strong>：<code>ExcReq = (ExcCode != 0) &amp; ~EXL</code></li><li><strong>总请求</strong>：<code>Req = IntReq | ExcReq</code></li></ul><h3 id="2-2-流水线改造-Pipeline-Modification"><a href="#2-2-流水线改造-Pipeline-Modification" class="headerlink" title="2.2 流水线改造 (Pipeline Modification)"></a>2.2 流水线改造 (Pipeline Modification)</h3><p>引入异常后，流水线不再是一条直线，随时可能被“打断”。<br>在这里为了便于理解，我的理解如下，有两个程序区同时存在，分别是正常程序和异常处理程序，我们的CPU只能同时执行一个程序，这个程序默认是正常的  </p><ul><li>Req是从正常程序跳转到异常处理程序的开关</li><li>Eret是从异常处理程序跳转到正常程序的开关</li><li>两个开关只要有任何一个被启动了，CPU在此时被定格，<strong>原来程序的操作不对CPU产生任何影响，PC跳转到新程序继续执行</strong></li></ul><h4 id="异常信号流-Signal-Flow"><a href="#异常信号流-Signal-Flow" class="headerlink" title="异常信号流 (Signal Flow)"></a>异常信号流 (Signal Flow)</h4><p>所有的异常信号（如 <code>AdEL</code>, <code>Ov</code>, <code>RI</code>, <code>Syscall</code>）不再立即触发，而是跟随指令流水线流动，直到 <strong>M 级</strong> 才统一由 CP0 处理。</p><ul><li><strong>F 级</strong>：检测取指异常 (<code>AdEL</code>)。</li><li><strong>D 级</strong>：检测未知指令 (<code>RI</code>)、<code>Syscall</code>。</li><li><strong>E 级</strong>：检测算术溢出 (<code>Ov</code>)。</li><li><strong>M 级</strong>：检测访存地址异常 (<code>AdEL</code>&#x2F;<code>AdES</code>)，并汇总所有异常。</li></ul><h4 id="冲刷与跳转-Flush-Redirect"><a href="#冲刷与跳转-Flush-Redirect" class="headerlink" title="冲刷与跳转 (Flush &amp; Redirect)"></a>冲刷与跳转 (Flush &amp; Redirect)</h4><p>当 M 级 CP0 产生 <code>Req</code> (进入异常) 或检测到 <code>eret</code> (退出异常) 时，产生统一的 <code>flushExc</code> 信号：</p><ol><li><strong>清空流水线</strong>：<code>FD</code>, <code>DE</code>, <code>EM</code> 寄存器全部复位（插入 nop）。</li><li><strong>强制跳转</strong>：<ul><li><code>Req</code>：PC 跳转至 <code>0x4180</code> (异常入口)。</li><li><code>eret</code>：PC 跳转至 <code>EPC</code>。</li></ul></li></ol><p>这里我涉及异常的所有跳转（Req或Eret）都是在M级进行处理，而大部分人采用的是在D级识别到Eret直接跳转，两种模式各有利弊  </p><ul><li>在M级跳转需要识别到异常跳转，并清空所有的流水寄存器（同Req），并且拒绝MD模块的启动</li><li>在D级跳转无需清空后续流水寄存器和阻止MD模块，但需要阻塞让Eret的前级指令顺利执行</li></ul><h4 id="宏观-PC-与延迟槽-The-Tricky-Parts"><a href="#宏观-PC-与延迟槽-The-Tricky-Parts" class="headerlink" title="宏观 PC 与延迟槽 (The Tricky Parts)"></a>宏观 PC 与延迟槽 (The Tricky Parts)</h4><ul><li><strong>受害者 PC (Victim PC)</strong>：如果当前指令是延迟槽指令 (<code>BD=1</code>)，EPC 记录的是 <strong>前一条指令 (跳转指令)</strong> 的地址 (PC-4)，否则记录当前 PC。</li><li><strong>宏观 PC</strong>：为了配合评测机，必须输出“宏观 PC”。当发生中断时，宏观 PC 应指向受害者指令；当正常执行时，指向 M 级指令。</li></ul><p>需要注意的是，受害者PC具体是哪一条取决于BD的信息，而BD的信息是有可能会被<strong>错误冲刷</strong>掉的，让我们考虑流水寄存器都有哪些情况有可能被冲刷：</p><ul><li>全局Reset，所有信息都需要被清空，BD应该被清空</li><li>Req&#x2F;Eret，正常程序与异常处理程序之间跳转，BD应该被清空</li><li>stall，停顿产生的nop空泡，此时BD不应该被清空，因为这条nop是人为产生的，并不是原有指令，如果在这条nop产生中断，那么PC和BD指令会被错误的传入</li><li>与BD同理，PC的信息也和BD应该保持一致</li></ul><h2 id="3-系统桥与外设-Bridge-Peripherals"><a href="#3-系统桥与外设-Bridge-Peripherals" class="headerlink" title="3. 系统桥与外设 (Bridge &amp; Peripherals)"></a>3. 系统桥与外设 (Bridge &amp; Peripherals)</h2><p>由于引入了 Timer，CPU 的访存地址空间被划分为了 DM 区和 IO 区。<br>系统桥的作用就是根据地址的高位，将 CPU 的读写请求路由到正确的设备。</p><table><thead><tr><th align="left">地址范围</th><th align="left">设备</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>0x0000 ~ 0x2FFF</code></td><td align="left"><strong>DM</strong></td><td align="left">数据存储器</td></tr><tr><td align="left"><code>0x7F00 ~ 0x7F0B</code></td><td align="left"><strong>Timer0</strong></td><td align="left">计时器 0</td></tr><tr><td align="left"><code>0x7F10 ~ 0x7F1B</code></td><td align="left"><strong>Timer1</strong></td><td align="left">计时器 1</td></tr><tr><td align="left"><code>0x7F20 ~ ...</code></td><td align="left"><strong>IntGen</strong></td><td align="left">中断发生器 (评测用)</td></tr></tbody></table><h2 id="4-P7课上"><a href="#4-P7课上" class="headerlink" title="4. P7课上"></a>4. P7课上</h2><p>P7课上与前几个P的课上不同，前四题是课下CPU的强测分别是 功能强测、冒险强测、异常强测、中断强测 ，只要课下没问题课上就能通过<br>第五题是一个新加的指令，基本内容是CP0中新加寄存器来实现相应的新异常，只需要修改CP0中的逻辑和异常识别的逻辑即可，难度不高</p><p>我的第一次P7课上挂P，我觉得主要问题是在MD模块没有被阻止上出错了，核心原则还是<strong>原来程序的操作不对CPU产生任何影响，PC跳转到新程序继续执行</strong>，但是具体是不是这个问题我也无从得知了，黑盒魅力时刻，第二次顺利通过，<strong>恭喜自己CO通关</strong></p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P7">GitHub 项目指南文件夹 (P7)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P6</title>
      <link href="/2026/01/14/BUAA-CO-P6/"/>
      <url>/2026/01/14/BUAA-CO-P6/</url>
      
        <content type="html"><![CDATA[<h1 id="P6-Verilog-流水线-CPU-新增指令集"><a href="#P6-Verilog-流水线-CPU-新增指令集" class="headerlink" title="P6 - Verilog 流水线 CPU (新增指令集)"></a>P6 - Verilog 流水线 CPU (新增指令集)</h1><p>如果说 P5 是搭起了流水线的骨架，那么 P6 就是为其填充血肉。<br>P6 的核心任务是<strong>扩充指令集</strong>。虽然架构上不需要像 P5 那样重构，但在数据通路细节和冲突处理上需要加很多新内容。</p><p>我们需要支持包括乘除法、不同位宽的访存（Byte&#x2F;Half-word）以及更多的逻辑运算指令。</p><h2 id="1-设计要求与挑战"><a href="#1-设计要求与挑战" class="headerlink" title="1. 设计要求与挑战"></a>1. 设计要求与挑战</h2><p>在 P5 基础上，P6 需要新增以下几类指令：</p><ul><li><strong>R 型计算</strong>：<code>and</code>, <code>or</code>, <code>slt</code>, <code>sltu</code></li><li><strong>I 型计算</strong>：<code>addi</code>, <code>andi</code>, <code>ori</code></li><li><strong>访存指令</strong>：<code>lb</code>, <code>lh</code>, <code>lw</code>, <code>sb</code>, <code>sh</code>, <code>sw</code></li><li><strong>乘除指令</strong>：<code>mult</code>, <code>multu</code>, <code>div</code>, <code>divu</code>, <code>mfhi</code>, <code>mflo</code>, <code>mthi</code>, <code>mtlo</code></li><li><strong>跳转指令</strong>：<code>bne</code></li></ul><p>新增内容的难点主要集中在两点：</p><ol><li><strong>乘除法模块 (MD Unit)</strong></li><li><strong>非对齐访存 (BE&#x2F;DE)</strong></li></ol><h2 id="2-关键模块迭代"><a href="#2-关键模块迭代" class="headerlink" title="2. 关键模块迭代"></a>2. 关键模块迭代</h2><p>大部分组合逻辑模块（Splitter, GRF, EXT, NPC）的内部逻辑与 P5 基本一致，直接复用即可。<br>我主要重写或新增了以下模块：</p><h3 id="2-1-乘除模块-MD-Unit"><a href="#2-1-乘除模块-MD-Unit" class="headerlink" title="2.1 乘除模块 (MD Unit)"></a>2.1 乘除模块 (MD Unit)</h3><p>为了处理 <code>mult</code>, <code>div</code> 等多周期指令，我们需要设计一个独立的 MD 模块。<br><strong>为什么独立？</strong> 因为 ALU 本质上是单周期的组合逻辑，而乘除法耗时较长（模拟真实硬件），且结果为 64 位（Hi&#x2F;Lo 寄存器），整合进 ALU 会严重拖慢流水线效率。</p><p><strong>接口设计</strong>：</p><ul><li><code>start</code>：开始计算信号。</li><li><code>A</code>, <code>B</code>：32 位运算数。</li><li><code>MDop</code>：运算符 (mult&#x2F;div&#x2F;multu&#x2F;divu)。</li><li><code>HI</code>, <code>LO</code>：输出结果寄存器。</li><li><code>busy</code>：指示模块是否忙碌。</li></ul><p><strong>实现细节</strong>：</p><ol><li><strong>周期模拟</strong>：为了满足 P6 的时序要求（乘法 5 周期，除法 10 周期），模块内部维护一个 <code>counter</code> 计数器。</li><li><strong>输入锁存</strong>：在 <code>start</code> 有效的周期，使用内部寄存器 <code>A_r</code>, <code>B_r</code> 保存操作数。这是为了防止后续流水线继续流动导致输入操作数改变，影响正在进行的计算。</li></ol><ul><li>这个位置一定注意，如果内部不用寄存器维护的话，端口会随着流水线一起更新，计算的A和B就丢失了</li></ul><ol start="4"><li><strong>结果写回</strong>：为了便于控制，我选择将计算结果的更新和 HILO 寄存器的写入统一放在倒计时的最后一个周期。</li></ol><h3 id="2-2-访存接口改造-BE-DE"><a href="#2-2-访存接口改造-BE-DE" class="headerlink" title="2.2 访存接口改造 (BE &amp; DE)"></a>2.2 访存接口改造 (BE &amp; DE)</h3><p>P6 引入了 <code>sb</code>, <code>sh</code>, <code>lb</code>, <code>lh</code>，这意味着我们不能简单地读写 32 位数据。<br>为了保持 DM（Data Memory）作为标准 32 位 RAM 的纯粹性，我采用了 <strong>BE (Byte Enable)</strong> 和 <strong>DE (Data Extension)</strong> 两个“适配器”来包裹 DM。</p><h4 id="BE-Store-译码模块"><a href="#BE-Store-译码模块" class="headerlink" title="BE (Store 译码模块)"></a>BE (Store 译码模块)</h4><p>位于 DM 之前。根据指令类型和地址低两位，生成 DM 的字节使能信号 (<code>ByteEn</code>)。</p><table><thead><tr><th align="center">StoreType</th><th align="center">指令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>2&#39;b01</code></td><td align="center"><code>sw</code></td><td align="left">写 4 字节</td></tr><tr><td align="center"><code>2&#39;b10</code></td><td align="center"><code>sh</code></td><td align="left">写 2 字节 (对齐半字)</td></tr><tr><td align="center"><code>2&#39;b11</code></td><td align="center"><code>sb</code></td><td align="left">写 1 字节</td></tr></tbody></table><p><strong>核心逻辑 (以 sb 为例)</strong>：<br>当 <code>StoreType == sb</code> 时：</p><ul><li>若 <code>addr[1:0] == 00</code> -&gt; <code>ByteEn = 0001</code>, data 移位至 <code>[7:0]</code></li><li>若 <code>addr[1:0] == 01</code> -&gt; <code>ByteEn = 0010</code>, data 移位至 <code>[15:8]</code><br>…以此类推。这一步统一了所有 Store 指令的处理逻辑，DM 只需要认 <code>ByteEn</code> 即可，无需知道是 <code>sb</code> 还是 <code>sw</code>。</li></ul><h4 id="DE-Load-译码模块"><a href="#DE-Load-译码模块" class="headerlink" title="DE (Load 译码模块)"></a>DE (Load 译码模块)</h4><p>位于 DM 之后。负责接收 DM 读出的 32 位原始数据，根据指令类型进行截取和符号扩展。</p><ul><li><code>lb</code>：取对应字节 -&gt; 符号扩展至 32 位。</li><li><code>lbu</code> (扩展)：取对应字节 -&gt; 零扩展至 32 位。</li><li><code>lh</code>：取对应半字 -&gt; 符号扩展至 32 位。</li><li><code>lw</code>：直接输出原始数据。</li></ul><h3 id="2-3-Controller-指令分类法"><a href="#2-3-Controller-指令分类法" class="headerlink" title="2.3 Controller (指令分类法)"></a>2.3 Controller (指令分类法)</h3><p>由于指令数量激增，如果一条条写逻辑会非常乱。我采用了<strong>指令分类译码</strong>的策略：先根据 OpCode 和 Funct 将指令归类，再生成控制信号。</p><p><strong>分类策略</strong>：</p><ul><li><strong>Cal_R</strong>：<code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>slt</code>…</li><li><strong>Cal_I</strong>：<code>addi</code>, <code>andi</code>, <code>ori</code>…</li><li><strong>Cal_MD</strong>：<code>mult</code>, <code>div</code>…</li><li><strong>Mov_MD</strong>：<code>mfhi</code>, <code>mflo</code>…</li><li><strong>Load&#x2F;Store</strong>：<code>lw</code>, <code>sw</code>…</li><li><strong>Branch</strong>：<code>beq</code>, <code>bne</code>…</li></ul><p>通过这种分类，<code>ALUop</code>, <code>EXTop</code> 等信号的逻辑变得非常清晰。例如，只要是 <code>Load</code> 类指令，<code>MemToReg</code> 信号就统一置 1。</p><h2 id="3-冲突解决-Hazard-Handling"><a href="#3-冲突解决-Hazard-Handling" class="headerlink" title="3. 冲突解决 (Hazard Handling)"></a>3. 冲突解决 (Hazard Handling)</h2><p>P6 的冲突处理大体沿用 P5 的框架（转发逻辑完全一致），主要变动在于 <strong>乘除法模块产生的结构冒险</strong>。</p><h3 id="3-1-Stall-控制器-新增-Busy-阻塞"><a href="#3-1-Stall-控制器-新增-Busy-阻塞" class="headerlink" title="3.1 Stall 控制器 (新增 Busy 阻塞)"></a>3.1 Stall 控制器 (新增 Busy 阻塞)</h3><p>由于乘除法模块 (MD) 存在 <code>busy</code> 状态，当 MD 正在运算时，后续指令如果试图读写 HI&#x2F;LO 寄存器或开启新的乘除运算，必须阻塞。</p><p><strong>阻塞策略</strong>：<br>当 <code>E</code> 级正在使用 MD 模块 (即 <code>Start</code> 或 <code>Busy</code> 有效) <strong>且</strong> <code>D</code> 级指令为 MD 类指令 (需要使用 MD 模块) 时：</p><ul><li><strong>Action</strong>: 冻结 PC，冻结 F&#x2F;D 级寄存器，清空 D&#x2F;E 级寄存器（插入 nop）。</li><li><strong>效果</strong>: <code>D</code> 级指令原地等待，直到 <code>busy</code> 信号拉低。</li></ul><h3 id="3-2-Tuse-Tnew-更新"><a href="#3-2-Tuse-Tnew-更新" class="headerlink" title="3.2 Tuse&#x2F;Tnew 更新"></a>3.2 Tuse&#x2F;Tnew 更新</h3><p>基本逻辑不变，只需要将新增指令的时间参数填入即可。</p><ul><li><code>bne</code> 的处理逻辑同 <code>beq</code> (Tuse &#x3D; 0)。</li><li><code>store</code> 类指令 (<code>sh</code>, <code>sb</code>) 的 Tuse 逻辑同 <code>sw</code>。</li><li><code>load</code> 类指令 (<code>lh</code>, <code>lb</code>) 的 Tnew 逻辑同 <code>lw</code> (M 级产出)。</li></ul><h2 id="4-P6课上"><a href="#4-P6课上" class="headerlink" title="4. P6课上"></a>4. P6课上</h2><p>我也不知道为啥，但我的课上指令没有考察乘除模块的新增指令，所有的三条新增指令都与P5一致，所以这方面我也没经验，参考我的P5博客吧</p><p>P6与P5相比体感甚至更简单一点，因为新增的模块其实并没有对数据通路进行任何修改，所以冒险的处理逻辑没发生变化</p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P6">GitHub 项目指南文件夹 (P6)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P5</title>
      <link href="/2026/01/14/BUAA-CO-P5/"/>
      <url>/2026/01/14/BUAA-CO-P5/</url>
      
        <content type="html"><![CDATA[<h1 id="P5-用-Verilog-搭建流水线-CPU"><a href="#P5-用-Verilog-搭建流水线-CPU" class="headerlink" title="P5 - 用 Verilog 搭建流水线 CPU"></a>P5 - 用 Verilog 搭建流水线 CPU</h1><p>P5 的任务是设计一个 <strong>MIPS 五级流水线处理器</strong>。<br>指令集与 P4 相同（支持 <code>add</code>, <code>sub</code>, <code>ori</code>, <code>lw</code>, <code>sw</code>, <code>beq</code>, <code>lui</code>, <code>jal</code>, <code>jr</code>, <code>nop</code>），但架构上需要从“单周期”完全重写为“流水线”。</p><p>这是计组实验的第一个大坎，迈过这一步，后续的 P6、P7 也就是在这个架构上修修补补了。</p><h2 id="1-核心思路：为什么要流水线？"><a href="#1-核心思路：为什么要流水线？" class="headerlink" title="1. 核心思路：为什么要流水线？"></a>1. 核心思路：为什么要流水线？</h2><p>打个比方，<strong>单周期 (P3&#x2F;P4)</strong> 就像是所有指令一个个排队过独木桥。前一条指令没走完，下一条指令就不能上桥。虽然这样保证了每条指令的执行绝对正确，但这也意味着当 ALU 在忙碌时，DM 和 IM 都在“摸鱼”，硬件利用率极低。</p><p><strong>流水线 (P5)</strong> 则意味着“工厂流水线化”。我们将 CPU 划分为 <strong>IF, ID, EX, MEM, WB</strong> 五个阶段，让五条指令同时在 CPU 的不同阶段运行。效率提高了，但同时也引入了“前后指令打架”的问题——也就是<strong>冒险 (Hazard)</strong>。</p><p>流水线的冒险主要分为三大类：</p><ol><li><strong>结构冒险</strong>：硬件资源不够分。在课程设计中，由于我们将 IM 和 DM 分开了（哈佛架构），不需要考虑这个问题。</li><li><strong>数据冒险</strong>：下一条指令急需的数据，上一条指令还没算完或者还没写回去。</li><li><strong>控制冒险</strong>：主要是跳转指令（如 <code>beq</code>, <code>jal</code>）导致下一条指令地址不确定。</li></ol><h2 id="2-模块化设计与复用"><a href="#2-模块化设计与复用" class="headerlink" title="2. 模块化设计与复用"></a>2. 模块化设计与复用</h2><p>我们将 CPU 元件分为两类：<strong>组合元件</strong>与<strong>时序元件</strong>。</p><h3 id="2-1-旧模块复用-组合元件"><a href="#2-1-旧模块复用-组合元件" class="headerlink" title="2.1 旧模块复用 (组合元件)"></a>2.1 旧模块复用 (组合元件)</h3><p>大部分组合逻辑模块的功能与 P4 完全一致，不需要考虑流水线冲突，直接复用即可。</p><ul><li><strong>Splitter, EXT, ALU, NPC, IM, DM</strong>：完全照搬 P4。</li></ul><h3 id="2-2-改造模块-时序元件"><a href="#2-2-改造模块-时序元件" class="headerlink" title="2.2 改造模块 (时序元件)"></a>2.2 改造模块 (时序元件)</h3><ul><li><strong>GRF (通用寄存器堆)</strong>：<br>  这是 P5 中唯一需要修改内部逻辑的旧模块。<br>  <strong>内部转发机制</strong>：当在同一个周期内，既要对寄存器 <code>$x</code> 进行写，又要读取寄存器 <code>$x</code> 时，旧的 GRF 会读出旧数据。我们需要修改逻辑，实现<strong>内部转发 (Internal Forwarding)</strong>——即检测到读写地址相同且写使能有效时，直接把“写入数据”旁路给“读出端口”。</li></ul><h2 id="3-冲突解决：转发与阻塞-The-Core"><a href="#3-冲突解决：转发与阻塞-The-Core" class="headerlink" title="3. 冲突解决：转发与阻塞 (The Core)"></a>3. 冲突解决：转发与阻塞 (The Core)</h2><p>这是 P5 最核心的部分。我采用了 <strong>“AT 法” (Arrival Time &amp; Time Use)</strong> 来统一处理数据冒险。</p><h3 id="3-1-信号定义"><a href="#3-1-信号定义" class="headerlink" title="3.1 信号定义"></a>3.1 信号定义</h3><p>在 Controller 中，我为每条指令定义了三个关键的时间参数：</p><ul><li><strong>TuseRs&#x2F;TuseRt</strong>：指令在 D 级时，还需要多少个周期才能使用 Rs&#x2F;Rt 的值？</li><li><strong>Tnew</strong>：指令在某个阶段（E&#x2F;M&#x2F;W），距离产生结果并写入寄存器还需要多少个周期？</li></ul><p><strong>Tuse&#x2F;Tnew 表格设计：</strong></p><table><thead><tr><th align="center">指令</th><th align="center">TuseRs</th><th align="center">TuseRt</th><th align="center">Tnew (at E stage)</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>add/sub</code></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="left">E 级算出结果</td></tr><tr><td align="center"><code>ori/lui</code></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="left">E 级算出结果</td></tr><tr><td align="center"><code>lw</code></td><td align="center">1</td><td align="center">x</td><td align="center">2</td><td align="left">M 级读出数据</td></tr><tr><td align="center"><code>sw</code></td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="left">不产生写入寄存器的数据</td></tr><tr><td align="center"><code>beq</code></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="left">D 级就需要判断跳转</td></tr><tr><td align="center"><code>jal</code></td><td align="center">x</td><td align="center">x</td><td align="center">0</td><td align="left">D 级已确定 PC+8</td></tr><tr><td align="center"><code>jr</code></td><td align="center">0</td><td align="center">x</td><td align="center">0</td><td align="left">D 级需要寄存器值跳转</td></tr></tbody></table><h3 id="3-2-转发设计-Forwarding"><a href="#3-2-转发设计-Forwarding" class="headerlink" title="3.2 转发设计 (Forwarding)"></a>3.2 转发设计 (Forwarding)</h3><p><strong>原则</strong>：只要数据算出来了，就赶紧给需要的地方送过去。<br><strong>通路</strong>：我设计了 5 条转发通路。</p><ol><li><strong>M -&gt; E</strong>：ALU 算出的结果直接给下一条指令的 ALU 输入。</li><li><strong>W -&gt; E</strong>：WB 级回写的数据给 ALU 输入。</li><li><strong>M -&gt; D</strong>：ALU 结果给 Branch 判断。</li><li><strong>W -&gt; D</strong>：WB 级数据给 Branch 判断。</li><li><strong>GRF 内部转发</strong>：解决 WB 级和 ID 级的重叠。</li></ol><p><strong>转发控制器 (Forward Unit)</strong>：<br>负责产生 <code>ForwardAE</code>, <code>ForwardBE</code> (EX 级 ALU 用) 和 <code>CmpAD</code>, <code>CmpBD</code> (ID 级比较器用) 信号。</p><ul><li><em>逻辑</em>：优先转发最新鲜的数据（M 级优先级 &gt; W 级）。</li></ul><h3 id="3-3-阻塞设计-Stalling"><a href="#3-3-阻塞设计-Stalling" class="headerlink" title="3.3 阻塞设计 (Stalling)"></a>3.3 阻塞设计 (Stalling)</h3><p><strong>原则</strong>：当“供不应求”时（即 <code>Tuse &lt; Tnew</code>）此时需要使用的新数据还没产生，必须暂停流水线等待。<br>这种情况通常发生在 <strong>Load-Use</strong> 冒险中（例如 <code>lw</code> 后面紧跟一个 <code>add</code>），数据还在内存里，怎么转发都来不及，只能停一拍。</p><p><strong>阻塞逻辑</strong>：<br>当满足 <code>Tuse &lt; Tnew</code> 时，执行阻塞操作：</p><ol><li><strong>冻结 PC</strong>：<code>PC_En = 0</code>。</li><li><strong>冻结 IF&#x2F;ID 寄存器</strong>：<code>FD_Reg_En = 0</code>。</li><li><strong>清空 ID&#x2F;EX 寄存器</strong>：将 ID&#x2F;EX 流水线寄存器同步复位（Flush），插入一个 <code>nop</code> 气泡。</li></ol><h2 id="4-控制信号与流水表格"><a href="#4-控制信号与流水表格" class="headerlink" title="4. 控制信号与流水表格"></a>4. 控制信号与流水表格</h2><p>P5 的控制信号需要跟随指令在流水线中流动。我采用了<strong>集中式译码</strong>：在 ID 级一次性生成所有控制信号，然后打包装入流水线寄存器。</p><p><strong>主电路流水信号流向表 (部分)</strong>：</p><table><thead><tr><th align="center">信号类别</th><th align="center">信号</th><th align="center">IF</th><th align="center">→</th><th align="center">ID</th><th align="center">→</th><th align="center">EX</th><th align="center">→</th><th align="center">MEM</th><th align="center">→</th><th align="center">WB</th><th align="center">生成</th><th align="center">使用</th></tr></thead><tbody><tr><td align="center"><strong>指令</strong></td><td align="center">instr</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">IF</td><td align="center">ID</td></tr><tr><td align="center"><strong>GRF读</strong></td><td align="center">readData1</td><td align="center"></td><td align="center"></td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">ID</td><td align="center">EX</td></tr><tr><td align="center"><strong>立即数</strong></td><td align="center">imm32</td><td align="center"></td><td align="center"></td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">ID</td><td align="center">EX</td></tr><tr><td align="center"><strong>控制</strong></td><td align="center">RegWrite</td><td align="center"></td><td align="center"></td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">ID</td><td align="center">WB</td></tr><tr><td align="center"></td><td align="center">MemToReg</td><td align="center"></td><td align="center"></td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">ID</td><td align="center">WB</td></tr><tr><td align="center"><strong>跳转</strong></td><td align="center">pcPlus4</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">→</td><td align="center">✔</td><td align="center">IF</td><td align="center">WB</td></tr></tbody></table><h2 id="5-思考与-FAQ-Reflection"><a href="#5-思考与-FAQ-Reflection" class="headerlink" title="5. 思考与 FAQ (Reflection)"></a>5. 思考与 FAQ (Reflection)</h2><p>在设计过程中，对几个关键问题的思考有助于理清逻辑。</p><ul><li><p><strong>Q1: 为什么采用“提前分支判断” (Early Branch)?</strong><br>  在这个位置我进行过一次重构，第一次的流水线结构是在 <code>E级的ALU执行分支判断和跳转</code> 这样的好处是可以少些两条数据通路，由于D级不涉及对寄存器去除的数的任何行为，两条转发到D级的数据通路都可以被删除，代价是某些情景（比如lw-beq）会产生两个周期的阻塞，阻塞的概率更高。<br>  从课程组的答复中也得知E级进行分支判断是有可能效率低于评测要求而导致不通过的，因此进行了重构将比较器前提至D级。</p></li><li><p><strong>Q2: 课上新增指令怎么办？</strong><br>  P5 的架构优势在于<strong>标准化</strong>。新增指令只需：</p><ol><li>修改 <code>Controller</code>，定义新指令的 Tuse&#x2F;Tnew 和控制信号。</li><li>如果涉及新运算，修改 <code>ALU</code>。</li><li>数据通路通常不需要大改，除非涉及完全陌生的操作（如条件移动等）。</li></ol></li></ul><h2 id="6-P5课上总结"><a href="#6-P5课上总结" class="headerlink" title="6. P5课上总结"></a>6. P5课上总结</h2><p>课上三道例题，基本可以分为ALU计算、新条件跳转、条件访存<br>前两道题只涉及到数据通路的修改，如果采取的是AT法基本跟着标准化流程走即可<br>第三题访存题的难点在于，在这条指令中你只有<strong>在MEM阶段取出数后才知道要操作的具体寄存器</strong>，这就导致了WAR的数据冒险无法通过转发解决，只能暴力阻塞，而<strong>暴力阻塞又可能导致TLE，因此在暴力阻塞前需要提前判断，将不需要阻塞的情况排除</strong>(比如目标寄存器只取决于DM取数的后四位，那么就代表只有1-15号寄存器会被修改，其他情况不可能发生数据冒险)  </p><p>总的来说P5课上的题目虽然逻辑不变，但还是和前几个P相比需要更多思考，也更考验课下的具体实现是否具有标准化特点。</p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P5">GitHub 项目指南文件夹 (P5)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P4</title>
      <link href="/2025/12/01/BUAA-CO-P4/"/>
      <url>/2025/12/01/BUAA-CO-P4/</url>
      
        <content type="html"><![CDATA[<h1 id="P4-用-Verilog-搭建单周期-CPU"><a href="#P4-用-Verilog-搭建单周期-CPU" class="headerlink" title="P4 - 用 Verilog 搭建单周期 CPU"></a>P4 - 用 Verilog 搭建单周期 CPU</h1><p>P4 基本就是把 P3 翻译到 Verilog，按模块进行翻译即可。<br>这部分的模块命名规范最好保持一致，因为 P5（流水线）还都基本可以复用。</p><h2 id="1-设计概述"><a href="#1-设计概述" class="headerlink" title="1. 设计概述"></a>1. 设计概述</h2><p><strong>指令集新增</strong>：在 P3 基础上增加了 <code>jal</code> (跳转并链接) 和 <code>jr</code> (寄存器跳转)。<br><strong>主要工作</strong>：将 Logisim 的图形化连线转换为 Verilog 的 RTL 描述。</p><p>这里只给出新加或修改的模块逻辑，其他模块参照 P3 的博客。</p><h2 id="2-关键模块更新"><a href="#2-关键模块更新" class="headerlink" title="2. 关键模块更新"></a>2. 关键模块更新</h2><h3 id="NPC-下一指令地址计算"><a href="#NPC-下一指令地址计算" class="headerlink" title="NPC (下一指令地址计算)"></a>NPC (下一指令地址计算)</h3><p>在加入 <code>jal</code> 和 <code>jr</code> 后，<code>NextPC</code> 的计算分为四种情况：</p><table><thead><tr><th align="center">指令情况</th><th align="left">PC 计算方式 (Verilog 描述)</th></tr></thead><tbody><tr><td align="center">顺序执行</td><td align="left"><code>PC = PC + 4</code></td></tr><tr><td align="center"><code>beq</code> 跳转</td><td align="left"><code>PC = PC + 4 + (imm16 &lt;&lt; 2)</code></td></tr><tr><td align="center"><code>jal</code> 跳转</td><td align="left"><code>PC = { (PC + 4)[31:28], imm26, 2&#39;b00 }</code></td></tr><tr><td align="center"><code>jr</code> 跳转</td><td align="left"><code>PC = $31</code> (即 <code>GRF[31]</code>)</td></tr></tbody></table><h3 id="Controller-控制信号生成"><a href="#Controller-控制信号生成" class="headerlink" title="Controller (控制信号生成)"></a>Controller (控制信号生成)</h3><p>负责根据 <code>OpCode</code> 和 <code>Funct</code> 生成控制信号。<br>我依然采用 <strong>指令译码 + 信号映射</strong> 的方式。</p><h4 id="新增指令译码-Decoder"><a href="#新增指令译码-Decoder" class="headerlink" title="新增指令译码 (Decoder)"></a>新增指令译码 (Decoder)</h4><ul><li><code>jal</code> (OpCode: <code>000011</code>)</li><li><code>jr</code> (R-Type, Funct: <code>001000</code>)</li></ul><h4 id="控制信号表-Control-Signals"><a href="#控制信号表-Control-Signals" class="headerlink" title="控制信号表 (Control Signals)"></a>控制信号表 (Control Signals)</h4><p>这里我把 <code>jal</code> 的 “PC+4” 写入操作也放到 ALU 里计算了。</p><ul><li><strong>优化建议</strong>：实际上更推荐为 <code>jal</code> 单独走一条数据通路（DataPath），可以简化 ALU 的设计，让控制信号更纯粹。</li></ul><table><thead><tr><th align="center">指令</th><th align="center">RegDst</th><th align="center">RegWE</th><th align="center">ALUsrcA</th><th align="center">ALUsrcB</th><th align="center">ALUop</th><th align="center">DmWE</th><th align="center">MemToReg</th><th align="center">Branch</th><th align="center">Jump</th><th align="center">Jrsign</th></tr></thead><tbody><tr><td align="center"><strong>add</strong></td><td align="center"><code>01</code> (rd)</td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>add</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>sub</strong></td><td align="center"><code>01</code> (rd)</td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>sub</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>ori</strong></td><td align="center"><code>00</code> (rt)</td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>or</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>lw</strong></td><td align="center"><code>00</code> (rt)</td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>add</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>sw</strong></td><td align="center"><code>00</code> (rt)</td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>add</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>beq</strong></td><td align="center"><code>00</code></td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>sub</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>jal</strong></td><td align="center"><code>10</code> ($31)</td><td align="center"><code>1</code></td><td align="center"><code>01</code></td><td align="center"><code>10</code></td><td align="center"><code>add</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><strong>jr</strong></td><td align="center"><code>00</code></td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>0000</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td></tr></tbody></table><blockquote><p><strong>注</strong>：<code>ALUsrcA</code> 和 <code>ALUsrcB</code> 变为了 2 位，以支持 <code>jal</code> 所需的 PC 值和常数 4。</p></blockquote><h2 id="3-P4-课上总结"><a href="#3-P4-课上总结" class="headerlink" title="3. P4 课上总结"></a>3. P4 课上总结</h2><p>时间太久远没啥印象了，反正指令形式和 P3 基本一样。<br>换成 Verilog 描述之后，直接把 RTL 式子翻译成代码即可，比 Logisim 连线舒服太多。</p><p>P4 还是单周期 CPU，加新指令完全无需考虑前后指令的影响（冒险&#x2F;冲突），只需要处理好每一条指令本身的数据通路即可。</p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P4">GitHub 项目指南文件夹 (P4)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P3</title>
      <link href="/2025/12/01/BUAA-CO-P3/"/>
      <url>/2025/12/01/BUAA-CO-P3/</url>
      
        <content type="html"><![CDATA[<h1 id="P3-用-Logisim-搭建单周期-CPU"><a href="#P3-用-Logisim-搭建单周期-CPU" class="headerlink" title="P3 - 用 Logisim 搭建单周期 CPU"></a>P3 - 用 Logisim 搭建单周期 CPU</h1><h2 id="1-设计要求与规划"><a href="#1-设计要求与规划" class="headerlink" title="1. 设计要求与规划"></a>1. 设计要求与规划</h2><p><strong>目标</strong>：设计一款 32 位单周期处理器。<br><strong>指令集</strong>：<code>add</code>, <code>sub</code>, <code>ori</code>, <code>lw</code>, <code>sw</code>, <code>beq</code>, <code>lui</code>, <code>nop</code>。</p><ul><li><code>nop</code> 为空指令。</li><li><code>add</code>, <code>sub</code> 为无符号运算。</li></ul><p>根据要求，我将 CPU 拆解为以下核心模块：</p><h2 id="2-核心模块设计"><a href="#2-核心模块设计" class="headerlink" title="2. 核心模块设计"></a>2. 核心模块设计</h2><h3 id="IFU-取指单元"><a href="#IFU-取指单元" class="headerlink" title="IFU (取指单元)"></a>IFU (取指单元)</h3><ul><li><strong>功能</strong>：包含 PC（程序计数器）和 IM（指令存储器）。</li><li><strong>地址转换</strong>：PC 范围 <code>0x3000 ~ 0x6FFF</code>，而 ROM 地址从 0 开始。<ul><li><em>计算公式</em>：<code>IM_Addr = (PC - 0x00003000) &gt;&gt; 2</code>（因为每条指令占 4 字节）。</li></ul></li></ul><h3 id="GRF-通用寄存器堆"><a href="#GRF-通用寄存器堆" class="headerlink" title="GRF (通用寄存器堆)"></a>GRF (通用寄存器堆)</h3><p>要求同 P0 课下完成的 GRF，直接 Copy 过来即可。</p><h3 id="ALU-算数逻辑运算单元"><a href="#ALU-算数逻辑运算单元" class="headerlink" title="ALU (算数逻辑运算单元)"></a>ALU (算数逻辑运算单元)</h3><p>需要在该模块中实现 32 位加、减、或、与、比较大小的功能。</p><table><thead><tr><th align="center">运算编码 (ALUop)</th><th align="left">运算操作</th></tr></thead><tbody><tr><td align="center"><code>0000</code></td><td align="left">A + B</td></tr><tr><td align="center"><code>0001</code></td><td align="left">A - B</td></tr><tr><td align="center"><code>0010</code></td><td align="left">A | B</td></tr><tr><td align="center"><code>0011</code></td><td align="left">A &amp; B</td></tr><tr><td align="center"><code>0100</code></td><td align="left"><code>{B[15:0], 16&#39;h0000}</code> (LUI 操作)</td></tr></tbody></table><h3 id="DM-数据存储器-EXT-扩展单元"><a href="#DM-数据存储器-EXT-扩展单元" class="headerlink" title="DM (数据存储器) &amp; EXT (扩展单元)"></a>DM (数据存储器) &amp; EXT (扩展单元)</h3><ul><li><strong>DM</strong>：使用 RAM 实现，容量 3072 × 32bit。需支持异步复位。地址采用 <code>(Addr &gt;&gt; 2)</code> 方式字对齐。</li><li><strong>EXT</strong>：支持零扩展 (Zero-Ext) 和符号扩展 (Sign-Ext)。</li></ul><h3 id="Controller-控制单元"><a href="#Controller-控制单元" class="headerlink" title="Controller (控制单元)"></a>Controller (控制单元)</h3><p>这是最麻烦的部分。我将解码逻辑分为 <strong>“和逻辑” (Decoder)</strong> 和 <strong>“与逻辑” (Signals)</strong>。</p><ol><li><strong>和逻辑</strong>：根据 <code>OpCode</code> 和 <code>Funct</code> 译码出具体的指令信号（如 <code>is_add</code>, <code>is_lw</code>）。</li><li><strong>与逻辑</strong>：根据指令信号生成控制信号。</li></ol><table><thead><tr><th align="center">指令</th><th align="center">RegDst</th><th align="center">RegWE</th><th align="center">ALUsrc</th><th align="center">ALUop</th><th align="center">DmWE</th><th align="center">MemToReg</th><th align="center">Branch</th></tr></thead><tbody><tr><td align="center"><code>add</code></td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0000</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><code>sub</code></td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0001</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><code>ori</code></td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0010</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><code>lui</code></td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0100</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center"><code>lw</code></td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0000</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center"><code>sw</code></td><td align="center">x</td><td align="center">0</td><td align="center">1</td><td align="center">0000</td><td align="center">1</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center"><code>beq</code></td><td align="center">x</td><td align="center">0</td><td align="center">0</td><td align="center">x</td><td align="center">0</td><td align="center">x</td><td align="center">1</td></tr></tbody></table><h2 id="3-P3-课上与“挂科”复盘"><a href="#3-P3-课上与“挂科”复盘" class="headerlink" title="3. P3 课上与“挂科”复盘"></a>3. P3 课上与“挂科”复盘</h2><p>说实话，P3 课上我做了<strong>二周目</strong>（第一周挂了）。Logisim 对我来说确实手感一般。</p><h3 id="课上题型总结"><a href="#课上题型总结" class="headerlink" title="课上题型总结"></a>课上题型总结</h3><ol><li><strong>计算类指令</strong>：只需要修改 ALU 和 Ctrl。</li><li><strong>条件跳转指令</strong>：可能含有条件写入。需要修改 NPC，Ctrl 连出一条新信号与 <code>cmp</code> 结果相与。<ul><li><em>避坑</em>：条件写入如果不满足条件，GRF 的使能 <code>RegWE</code> 一定要是 0！否则评测机会报写入错误。</li></ul></li><li><strong>访存指令</strong>：可能会涉及 <code>for</code> 循环。Logisim 写硬件循环太痛苦，如果循环次数不多，建议直接<strong>枚举展开</strong>（暴力美学）。</li></ol><h3 id="碎碎念：因祸得福"><a href="#碎碎念：因祸得福" class="headerlink" title="碎碎念：因祸得福"></a>碎碎念：因祸得福</h3><p>第一次闯关上机就寄了，当时心里确实没底。<br>但卡关回来后，我对课下 CPU 做了很多优化，最核心的一点是：<strong>在 Controller 中留出了给新信号的预留位置</strong>。</p><p>这样在课上加指令时，不会在重复连线上浪费时间。这种“预留思想”一直延续到了之后所有的上机，确实省了很多麻烦。<br>后续的上机也证明了，P3 卡关不一定是坏事，反而因为有两周的充裕时间去打磨 CPU，对后续的 P4、P5 更有信心了。</p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P3">GitHub 项目指南文件夹 (P3)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Logisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P2</title>
      <link href="/2025/12/01/BUAA-CO-P2/"/>
      <url>/2025/12/01/BUAA-CO-P2/</url>
      
        <content type="html"><![CDATA[<h1 id="P2-学习使用-MIPS"><a href="#P2-学习使用-MIPS" class="headerlink" title="P2 - 学习使用 MIPS"></a>P2 - 学习使用 MIPS</h1><p>P2 的学习目标是学会使用 <strong>MIPS 汇编语言</strong> 编写程序，或者说把 C 语言程序“人脑编译”成 MIPS 语言。</p><p>在后续的 CPU 迭代中，MIPS 语言主要是用来写测试程序的。所以最基本的事情就是学会写测试程序。这与 P2 课上考察的内容（算法实现）不能说毫无联系，只能说完全无关……但这是必经之路。</p><h2 id="1-P2-课下作业-Homework"><a href="#1-P2-课下作业-Homework" class="headerlink" title="1. P2 课下作业 (Homework)"></a>1. P2 课下作业 (Homework)</h2><p>P2 课下共四道题目，分别对应不同的汇编技巧。</p><h3 id="P2-L0-matrix-矩阵乘法"><a href="#P2-L0-matrix-矩阵乘法" class="headerlink" title="P2_L0_matrix (矩阵乘法)"></a>P2_L0_matrix (矩阵乘法)</h3><p>很简单的一个 $n$ 阶矩阵乘法，主要用来复习一下矩阵的内存读写操作（行优先存储的地址计算）。</p><h3 id="P2-L0-judge-回文串判断"><a href="#P2-L0-judge-回文串判断" class="headerlink" title="P2_L0_judge (回文串判断)"></a>P2_L0_judge (回文串判断)</h3><p>判断是否是回文串。</p><ul><li><strong>注意点</strong>：<code>syscall</code> 的参数区别。当 <code>$v0</code> 为 8 和 12 时，采取的输入方式不同（缓冲区处理、结束符等），需要查阅手册确认。</li></ul><h3 id="P2-L0-conv-矩阵卷积"><a href="#P2-L0-conv-矩阵卷积" class="headerlink" title="P2_L0_conv (矩阵卷积)"></a>P2_L0_conv (矩阵卷积)</h3><p>输出初始矩阵经过卷积核计算后的卷积矩阵。</p><ul><li><strong>实现思路</strong>：除了计算方式和第一题不一样，其他基本都一样。</li><li><strong>易错点</strong>：涉及到多重循环时，注意<strong>在内部的循环开始前要将循环变量清零</strong>！这是汇编里最容易忘记的步骤。</li></ul><h3 id="P2-L0-full-1-全排列与递归"><a href="#P2-L0-full-1-全排列与递归" class="headerlink" title="P2_L0_full_1 (全排列与递归)"></a>P2_L0_full_1 (全排列与递归)</h3><p>题目要求输出输入整数的全排列，复习了一下 MIPS 中<strong>函数调用</strong>与<strong>堆栈管理</strong>的问题。</p><p><strong>递归调用的核心原则：</strong><br>要注意在调用前后保护函数中寄存器的值，严格遵循“出栈入栈”的规则：</p><ol><li><strong>返回地址保护</strong>：应当在 <code>jal</code> 跳转前保存 <code>$ra</code>，并在返回 <code>$ra</code> 后立刻出栈恢复。</li><li><strong>上下文保护</strong>：在调用函数前保护寄存器时，应当考虑到<strong>所有被修改的寄存器</strong>。<ul><li><em>技巧</em>：这里的“被修改”指的不是在函数运算中被修改，而是在函数中充当“跨函数常量”的值。简单判断方法：<strong>入栈代码后，所有被使用的寄存器都要入栈</strong>。</li></ul></li></ol><h2 id="2-P2-课上测试-In-Class-Exam"><a href="#2-P2-课上测试-In-Class-Exam" class="headerlink" title="2. P2 课上测试 (In-Class Exam)"></a>2. P2 课上测试 (In-Class Exam)</h2><p>和课下基本一致，题面都会给出相对应的 C 语言代码，做好“翻译官”的工作即可。<br>就算没过对后续影响也不大，心态要调整好。</p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P2">GitHub 项目指南文件夹 (P2)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> MIPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P1</title>
      <link href="/2025/12/01/BUAA-CO-P1/"/>
      <url>/2025/12/01/BUAA-CO-P1/</url>
      
        <content type="html"><![CDATA[<h1 id="P1-学习使用-Verilog"><a href="#P1-学习使用-Verilog" class="headerlink" title="P1 - 学习使用 Verilog"></a>P1 - 学习使用 Verilog</h1><p>P1 的核心目的在于学会怎么使用 <strong>Verilog</strong> 对你要使用的模块进行建模。个人觉得这是 P2 前最重要的一个阶段，因为后续迭代开发（P2 及以后）全部依赖 Verilog。</p><p>学习 Verilog 过程中可能遇到的困难，我从环境、语法、调试三个维度整理了一下。</p><h2 id="1-开发环境与工具-Environment"><a href="#1-开发环境与工具-Environment" class="headerlink" title="1. 开发环境与工具 (Environment)"></a>1. 开发环境与工具 (Environment)</h2><h3 id="ISE-安装"><a href="#ISE-安装" class="headerlink" title="ISE 安装"></a>ISE 安装</h3><blockquote><p><strong>重要的事情说三遍：一步一步跟着官方教程走是没问题的！</strong></p></blockquote><p>ISE 确实是比较老的软件了，有一些玄学问题：</p><ul><li><strong>重启大法</strong>：有的地方安装完没法仿真，重启一下电脑就好了（我第一次就是这样解决的）。</li><li><strong>虚拟机问题</strong>：根据个人情况，不是必须</li></ul><h3 id="波形调试-Simulation"><a href="#波形调试-Simulation" class="headerlink" title="波形调试 (Simulation)"></a>波形调试 (Simulation)</h3><p>这个只能说“习惯就好”。刚上手确实觉得乱，不太直观，但多调试几次找到感觉就行了。</p><h2 id="2-Verilog-核心语法难点"><a href="#2-Verilog-核心语法难点" class="headerlink" title="2. Verilog 核心语法难点"></a>2. Verilog 核心语法难点</h2><p>Verilog 的语法框架和 C 语言没啥区别，主要增加了一些硬件描述特有的概念。</p><h3 id="2-1-阻塞与非阻塞赋值"><a href="#2-1-阻塞与非阻塞赋值" class="headerlink" title="2.1 阻塞与非阻塞赋值"></a>2.1 阻塞与非阻塞赋值</h3><p>这是 Verilog 新概念中理解稍微费点劲的地方。</p><ul><li><p><strong>非阻塞赋值 (<code>&lt;=</code>)</strong>：指令并行执行，不会阻碍后续语句。</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    A &lt;= B; <span class="comment">// T0 时刻，取 B 的旧值准备赋给 A</span></span><br><span class="line">    B &lt;= C; <span class="comment">// T0 时刻，取 C 的旧值准备赋给 B</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// 结果：A 和 B 的更新在时钟沿通过后同时生效，实现了数据移位</span></span><br></pre></td></tr></table></figure></li><li><p><strong>阻塞赋值 (<code>=</code>)</strong>：指令顺序执行。</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    A = B; <span class="comment">// 立即将 B 的值赋给 A</span></span><br><span class="line">    B = C; <span class="comment">// 立即将 C 的值赋给 B</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// 结果：B 的值先传给 A，然后 B 被 C 覆盖。具有顺序性。</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-有符号数运算"><a href="#2-2-有符号数运算" class="headerlink" title="2.2 有符号数运算"></a>2.2 有符号数运算</h3><p>Verilog 默认是<strong>无符号数</strong>运算。在处理有符号数时，<code>$signed</code> 机制容易让人“翻车”。</p><ul><li><strong>坑点</strong>：虽然可以用 <code>$signed</code>，但这会隔绝位宽信息，导致原本需要自动位宽扩展的地方被截断。</li><li><strong>通解</strong>：所有参与运算的变量、常量全部加 <code>$signed</code>。如果需要扩展位宽，手动拼接一个扩展位，例如 <code>$signed(&#123;&#123;32&#123;1&#39;b0&#125;&#125;, data&#125;)</code>。</li></ul><h2 id="3-P1-课下作业-Homework"><a href="#3-P1-课下作业-Homework" class="headerlink" title="3. P1 课下作业 (Homework)"></a>3. P1 课下作业 (Homework)</h2><p>P1 课下六道题目，除了附加题外，都是实现基础的电子元件。</p><h3 id="基础元件-Splitter-ALU-EXT"><a href="#基础元件-Splitter-ALU-EXT" class="headerlink" title="基础元件 (Splitter, ALU, EXT)"></a>基础元件 (Splitter, ALU, EXT)</h3><p>三道不涉及时序逻辑的题目：</p><ol><li><strong>Splitter</strong>：拼接操作，一行代码解决。</li><li><strong>EXT (位扩展)</strong>：注意补位数字的位数即可。</li><li><strong>ALU (算术逻辑单元)</strong>：<ul><li>前五种功能简单。</li><li><strong>算术右移坑点</strong>：虽然可以直接写 <code>$signed($signed(a) &gt;&gt;&gt; b)</code>，但建议按位操作手动实现。我一开始 WA 就是因为直接写 <code>$signed(a) &gt;&gt;&gt; b</code> 导致 De 不出 Bug，手动拼接符号位更稳妥。</li></ul></li></ol><h3 id="状态机基础-Gray-EXPR"><a href="#状态机基础-Gray-EXPR" class="headerlink" title="状态机基础 (Gray, EXPR)"></a>状态机基础 (Gray, EXPR)</h3><p>两道状态机题目，状态数较少。<br>我采取的是标准<strong>两段式状态机</strong>设计：</p><ul><li><strong>组合逻辑</strong>：处理输出逻辑。</li><li><strong>时序逻辑</strong>：处理状态转移和状态存储。</li></ul><h3 id="附加题：BlockChecker-难点复盘"><a href="#附加题：BlockChecker-难点复盘" class="headerlink" title="附加题：BlockChecker (难点复盘)"></a>附加题：BlockChecker (难点复盘)</h3><p>这道题略微难思考，要求识别嵌套的 <code>begin</code> … <code>end</code> 块。</p><ul><li><p><strong>Attempt 1 (Failed)</strong>：<br>  设计了<strong>两个独立的状态机</strong>，分别处理 <code>begin</code> 和 <code>end</code> 的输入。结果过了 6&#x2F;9 个点，死活 De 不出 Bug。</p></li><li><p><strong>Attempt 2 (Success)</strong>：<br>  将两个状态机<strong>合二为一</strong>，共同处理输入序列，用不同的状态来识别 <code>begin</code> 和 <code>end</code>。</p></li><li><p><strong>思考 (Reflection)</strong>：<br>  虽然还没从理论上完全证明两种设计的区别，但从工程直觉上讲：<strong>同一个输入流最好不要在两个状态机里同时处理</strong>，否则容易导致状态同步混乱，输出匹配逻辑也会变得极其复杂。</p></li></ul><h2 id="4-P1-课上测试-In-Class-Exam"><a href="#4-P1-课上测试-In-Class-Exam" class="headerlink" title="4. P1 课上测试 (In-Class Exam)"></a>4. P1 课上测试 (In-Class Exam)</h2><h3 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h3><p>题目要求有点绕，虽然思路简单，但在考场上我实际写了 40 分钟+。</p><ul><li><strong>翻车现场</strong>：De 了半天 Bug，最后发现是把 <strong>按位与 (<code>&amp;</code>)</strong> 和 <strong>按位或 (<code>|</code>)</strong> 写反了……纯纯心态崩了。</li></ul><h3 id="时序电路-循环语句的坑"><a href="#时序电路-循环语句的坑" class="headerlink" title="时序电路 (循环语句的坑)"></a>时序电路 (循环语句的坑)</h3><p>题目要求根据每个周期输入的 <code>op</code> 执行对应指令。</p><ul><li><strong>难点</strong>：在单个周期内使用 <code>for</code> 循环。</li><li><strong>错误写法</strong>：直接在 <code>for</code> 循环里对 <code>reg</code> 类型变量进行非阻塞赋值 (<code>&lt;=</code>)。<ul><li><em>原因</em>：非阻塞赋值在整个 <code>always</code> 块结束后才更新，导致循环里拿到的永远是旧值，无法累加。</li></ul></li><li><strong>正确写法</strong>：定义一个 <code>integer</code> 类型的临时变量进行计算，循环结束后，再将结果非阻塞赋值给寄存器。</li></ul><hr><p><strong>P1 总结</strong>：难度适中，关键是熟悉 Verilog 的思维方式。</p><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P1">GitHub 项目指南文件夹 (P1)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P0</title>
      <link href="/2025/11/29/BUAA-CO-P0/"/>
      <url>/2025/11/29/BUAA-CO-P0/</url>
      
        <content type="html"><![CDATA[<h1 id="P0-学习使用-Logisim"><a href="#P0-学习使用-Logisim" class="headerlink" title="P0 - 学习使用 Logisim"></a>P0 - 学习使用 Logisim</h1><p>P0 简单来说就是教你如何使用 Logisim 设计电路。</p><p>在后续的实验课上，硬性要求只有 <strong>P3</strong> 需要使用 Logisim。所以如果很多地方一知半解也不用太担心，P4 以后纯看个人喜好，我过 P3 后是没碰过 Logisim 了。</p><p>我个人对 Logisim 用得很烂，感觉不如 Verilog 描述得那么直接——你想实现什么操作，还要先思考需要什么元件、怎么连线。</p><p>总的来讲，除了基本的门电路和元器件需要知道怎么用，教学组还喜欢考 <code>Bit Adder</code> 和 <code>Bit Checker</code> 这种不太常用的计算元件，知道是干啥的即可。</p><h2 id="1-P0-课下作业-Homework"><a href="#1-P0-课下作业-Homework" class="headerlink" title="1. P0 课下作业 (Homework)"></a>1. P0 课下作业 (Homework)</h2><p>P0 课下共有五道题目，涵盖了组合逻辑与时序逻辑。</p><h3 id="P0-L0-CRC-循环冗余校验"><a href="#P0-L0-CRC-循环冗余校验" class="headerlink" title="P0_L0_CRC (循环冗余校验)"></a>P0_L0_CRC (循环冗余校验)</h3><p>本题是一个简化的 CRC 组合电路设计，原数据帧为 8 位，除数为 4 位，主要考查了<strong>模二除法器</strong>的设计。</p><ul><li><strong>设计核心</strong>：当被除数首位为 0 时，直接跳过该轮除法（即余数为被除数）。</li></ul><h3 id="P0-L0-GRF-通用寄存器堆"><a href="#P0-L0-GRF-通用寄存器堆" class="headerlink" title="P0_L0_GRF (通用寄存器堆)"></a>P0_L0_GRF (通用寄存器堆)</h3><p>本题使用 Logisim 搭建一个包含 32 个 32 位寄存器的 <strong>GRF</strong>，需支持异步复位、读数据和写数据三种功能。</p><ul><li><strong>设计要点</strong>：注意写数据 <code>DMX</code> (解复用器) 的<strong>三态开关 (Three-state)</strong> 必须要开！否则会因为多个输出端连接到同一根线而导致冲突报错（这也是为了防止不修改的寄存器报错）。</li><li><em>注：这个模块在 P3 可以直接复用，好好设计能省点事。</em></li></ul><h3 id="P0-L1-ftoi-浮点转整数"><a href="#P0-L1-ftoi-浮点转整数" class="headerlink" title="P0_L1_ftoi (浮点转整数)"></a>P0_L1_ftoi (浮点转整数)</h3><p>本题是组合电路部分的附加题。<br>题目要求输入一个 16 位半精度浮点数，输出它的整数部分。虽然题干较为复杂，但题目要求有所简化。</p><p>对于 16 位半精度浮点数，分为 3 个部分：</p><table><thead><tr><th align="center">Sign (符号位)</th><th align="center">Exponent (指数位)</th><th align="center">Mantissa (尾数位)</th></tr></thead><tbody><tr><td align="center">1 bit</td><td align="center">5 bits</td><td align="center">10 bits</td></tr></tbody></table><p>根据 Exponent 的数值不同，分为 <code>Normalized</code>, <code>Denormalized</code>, <code>Infinity</code>, <code>NaN</code>。<br>看上去类别很多，但实际上后三种的数值一定在 $(-1, 1)$ 之中。换言之，<strong>整数部分一定为 0</strong>，因此只需要考虑 <code>Normalized</code> 一种情况即可。</p><ul><li><strong>处理逻辑</strong>：先处理整数部分的输出，最后再处理符号位。若符号位为 1，则对整数部分取反得答案。</li></ul><h3 id="P0-L0-FSM-Navigation-有限状态机"><a href="#P0-L0-FSM-Navigation-有限状态机" class="headerlink" title="P0_L0_FSM &amp; Navigation (有限状态机)"></a>P0_L0_FSM &amp; Navigation (有限状态机)</h3><p>两道时序电路设计题，均为有限状态机。第一题为 <strong>Moore</strong> 状态机，第二题为 <strong>Mealy</strong> 状态机。</p><ul><li><strong>区别</strong>：区别不大，状态转移方程比较简单。</li><li><strong>同步复位</strong>：第二题涉及到同步复位，需要用 <code>MUX</code> (多路选择器) 来实现。</li><li><strong>Mealy 机注意点</strong>：在设计 Mealy 状态机时，一定要注意<strong>输出电路</strong>涉及到的状态并非“当前时间的状态”，而是“寄存器中的状态”。</li></ul><h3 id="思考：Moore-vs-Mealy"><a href="#思考：Moore-vs-Mealy" class="headerlink" title="思考：Moore vs Mealy"></a>思考：Moore vs Mealy</h3><p>就我个人而言，我认为 Mealy 状态机就是 Moore 状态机的“状态转移”和“输出电路”拆分开来。Moore 状态机为了使输出和状态同步，用寄存器保存了一周期的输出结果。</p><p>换言之：</p><blockquote><p><strong>Moore 状态机状态转移电路 &#x3D; Mealy 状态机状态转移电路 ＋ 输出电路</strong></p></blockquote><p><strong>重点提醒</strong>：在有限状态机输出时，一定要注意输出的周期和要求匹不匹配！</p><h2 id="2-P0-课上测试-In-Class-Exam"><a href="#2-P0-课上测试-In-Class-Exam" class="headerlink" title="2. P0 课上测试 (In-Class Exam)"></a>2. P0 课上测试 (In-Class Exam)</h2><p>P0 课上三道题目，两道时序电路，一道组合电路。</p><h3 id="时序电路"><a href="#时序电路" class="headerlink" title="时序电路"></a>时序电路</h3><p>一道 Moore 机一道 Mealy 机。<br>考试时在“为寄存器赋初始值”这里卡了一会。其实用 <code>Counter</code> 赋值即可，注意<strong>不能直接赋值给寄存器</strong>，要直接赋值给 <code>pre</code> 数字。</p><h3 id="组合电路（复盘重点）"><a href="#组合电路（复盘重点）" class="headerlink" title="组合电路（复盘重点）"></a>组合电路（复盘重点）</h3><p>一开始看题干有点蒙圈，稍微思考了一会有了大概思路：首先判断初始楼层在哪，然后对其他三个楼层进行排序。每个初始楼层对应六种排序，共有四个初始楼层，共 24 种状态。</p><p>按理说直接 <code>Analyzed Circuit</code> 即可，结果硬是磨了一个多小时没 Debug 成功，没找到哪个状态设的有问题，最后不了了之。<br>反思下来，在考场上有点蒙圈，耐心不太够。很遗憾没能 AC。</p><p><strong>课下复盘：</strong><br>课下十分钟复现完毕。<br>结果发现是 <strong>Comparator (比较器) 的模式没改</strong>！<br>Logisim 的比较器默认识别的是<strong>有符号数 (Twos Complement)</strong>，而题目数据需要按<strong>无符号数 (Unsigned)</strong> 处理。考场上硬是没想到这一点。</p><blockquote><p><strong>P0 总结</strong>：难度不大，会写状态机、会用元件基本就能过。没过也补不了了，反正继续往前走吧。</p></blockquote><hr><p><strong>附件：</strong></p><ul><li><a href="https://github.com/Logarithm33/CO-2025/tree/main/P0">GitHub 项目指南文件夹 (P0)</a></li><li><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
            <tag> Logisim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Launching My Hexo Blog</title>
      <link href="/2025/11/29/Launching-Hexo-Blog/"/>
      <url>/2025/11/29/Launching-Hexo-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Launching-Hexo-Blog-Setup-Blog"><a href="#Launching-Hexo-Blog-Setup-Blog" class="headerlink" title="Launching Hexo Blog: Setup Blog"></a>Launching Hexo Blog: Setup Blog</h1><p> 新博客的第一篇文章，记录一下从0开始使用<code>Hexo</code>搭建博客的完整配置和上线过程  </p><h2 id="1-GitHub-预准备"><a href="#1-GitHub-预准备" class="headerlink" title="1. GitHub 预准备"></a>1. GitHub 预准备</h2><p>我使用 <strong>GitHub Pages</strong> 作为博客的托管平台，感觉是比较简单的托管平台，省去了买服务器的麻烦。</p><ol><li><p><strong>创建仓库</strong>：<br>在 GitHub 上创建一个新的公开仓库，命名格式必须为 <code>username.github.io</code>。</p><ul><li><em>注：其中 <code>username</code> 是我自己的 GitHub 用户名，如果你搭建自己的博客，换成你自己的用户名即可。</em></li></ul></li><li><p><strong>配置分支</strong>：<br>使用 <code>main</code> 分支来托管我的静态文件（即 Hexo 生成的 <code>public</code> 目录内容）。</p></li></ol><h2 id="2-配置-Node-js-和-Git-环境"><a href="#2-配置-Node-js-和-Git-环境" class="headerlink" title="2. 配置 Node.js 和 Git 环境"></a>2. 配置 Node.js 和 Git 环境</h2><p>Hexo 依赖于 <strong>Node.js</strong> (用于运行 Hexo) 和 <strong>Git</strong> (用于部署到 GitHub)。<br>因为我电脑上预先都有这两个环境，这里就跳过安装步骤了。</p><h2 id="3-下载-Hexo-环境"><a href="#3-下载-Hexo-环境" class="headerlink" title="3. 下载 Hexo 环境"></a>3. 下载 Hexo 环境</h2><p>在本地选择 <code>/my_blog</code> 作为我的博客根目录，在命令行中安装 Hexo CLI。</p><ol><li><p><strong>安装 Hexo</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化博客</strong>：<br>在目标目录下初始化 Hexo 框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init my_blog</span><br><span class="line"><span class="built_in">cd</span> my_blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p><strong>配置部署插件</strong>：<br>安装 Hexo 部署插件，用于自动化部署到 GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p><strong>预览网站</strong>：<br>进入 <code>my_blog</code> 文件夹后打开命令行，常用的指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 清除缓存文件和已生成的 public 文件夹</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成静态文件 (Generate)</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 启动本地服务器预览 (默认端口 4000)</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 部署生成的静态文件到远程仓库</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-Clone-Butterfly-主题"><a href="#4-Clone-Butterfly-主题" class="headerlink" title="4. Clone Butterfly 主题"></a>4. Clone Butterfly 主题</h2><p>其实到这一步已经可以上线了，但为了美观和更多功能，我决定使用 Hexo 下已经很成熟的 <code>Butterfly</code> 主题。<br>直接将 GitHub 上该项目克隆到 <code>themes</code> 文件夹中。</p><blockquote><p>这里贴上 Butterfly 的链接：<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 主题仓库</a></p></blockquote><ol><li><p><strong>下载主题</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master [https://github.com/jerryc127/hexo-theme-butterfly.git](https://github.com/jerryc127/hexo-theme-butterfly.git) themes/butterfly</span><br></pre></td></tr></table></figure></li><li><p><strong>启用主题</strong>：<br>修改博客根目录下的主配置文件 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="5-Customization-个性化配置"><a href="#5-Customization-个性化配置" class="headerlink" title="5. Customization (个性化配置)"></a>5. Customization (个性化配置)</h2><p>接下来就是个性化的部分。为了防止后续升级修改了主题文件，我采取了<strong>配置分离</strong>的办法：<br>将 <code>themes</code> 中的 <code>_config.yml</code> 复制到 <code>my_blog</code> 根目录，重命名为 <code>_config.butterfly.yml</code>，以后所有配置都写在这个文件里。</p><hr><p>第一篇博客随便写写，希望能帮到同样想要搭建自己博客、记录学习轨迹的朋友。<br>后续会上传更多跟日常学习有关的 Post！</p>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
