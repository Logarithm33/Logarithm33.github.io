<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-CO-P4</title>
      <link href="/2025/12/01/BUAA-CO-P4/"/>
      <url>/2025/12/01/BUAA-CO-P4/</url>
      
        <content type="html"><![CDATA[<h1 id="P4-用-Verilog-搭建单周期-CPU"><a href="#P4-用-Verilog-搭建单周期-CPU" class="headerlink" title="P4 用 Verilog 搭建单周期 CPU"></a>P4 用 Verilog 搭建单周期 CPU</h1><p>P4 基本就是把 P3 翻译到 Verilog，按模块进行翻译即可。</p><p>我个人觉得不用特别注意命名规范，到 P5 基本没有能复用的模块。</p><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><p>处理器为 32 位单周期处理器，支持 <code>add</code>, <code>sub</code>, <code>ori</code>, <code>lw</code>, <code>sw</code>, <code>beq</code>, <code>lui</code>, <code>jal</code>, <code>jr</code>, <code>nop</code> 指令。要求和 P3 课下基本相同，多加了 <code>jal</code> 和 <code>jr</code> 两条指令。</p><p>这里只给出新加或修改的模块，其他参照 P3 的博客。</p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p><strong>IFU（取指单元）</strong>  </p><p><strong>splitter（分位器）</strong>  </p><p><strong>GRF（通用寄存器堆）</strong>   </p><p><strong>ALU（算术逻辑运算单元）</strong>  </p><p><strong>DM（数据储存器）</strong>  </p><p><strong>EXT（扩展单元）</strong>  </p><p><strong>NPC（寻址单元）</strong> 负责计算下一条指令的地址，在加入 <code>jal</code> 和 <code>jr</code> 后分为四种情况：</p><table><thead><tr><th align="center">指令</th><th align="center">PC 计算方式</th></tr></thead><tbody><tr><td align="center"><code>add,sub,ori,lw,sw,lui,beq(A!=B)</code></td><td align="center"><code>PC = PC + 4</code></td></tr><tr><td align="center"><code>beq(A==B)</code></td><td align="center"><code>PC = PC + 4 + (immediate16 &lt;&lt; 2)</code></td></tr><tr><td align="center"><code>jal</code></td><td align="center"><code>PC = { (PC + 4)[31:28], immediate26, 2&#39;b00 }</code></td></tr><tr><td align="center"><code>jr</code></td><td align="center"><code>PC = $31</code></td></tr></tbody></table><p><strong>Controller(控制信号)</strong>   由于 <code>nop</code> 为空指令，因此与控制信号无关。</p><p>负责根据每条指令的 OPcode 生成对应的控制信号，将解码逻辑分为和逻辑和与逻辑。</p><h3 id="和逻辑（指令译码）"><a href="#和逻辑（指令译码）" class="headerlink" title="和逻辑（指令译码）"></a>和逻辑（指令译码）</h3><p>负责根据 OPcode 译码为指定的指令信号。</p><table><thead><tr><th align="center">OPcode</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center"><code>000000</code></td><td align="center">R 型指令</td></tr><tr><td align="center"><code>001101</code></td><td align="center">ori</td></tr><tr><td align="center"><code>001111</code></td><td align="center">lui</td></tr><tr><td align="center"><code>100011</code></td><td align="center">lw</td></tr><tr><td align="center"><code>101011</code></td><td align="center">sw</td></tr><tr><td align="center"><code>000100</code></td><td align="center">beq</td></tr><tr><td align="center"><code>000011</code></td><td align="center">jal</td></tr></tbody></table><p>对 R 型指令，根据 func 译码为指定指令信号，并与 OPcode 输出信号用与门连接。</p><table><thead><tr><th align="center">func</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center"><code>100000</code></td><td align="center">add</td></tr><tr><td align="center"><code>100010</code></td><td align="center">sub</td></tr><tr><td align="center"><code>001000</code></td><td align="center">jr</td></tr></tbody></table><h3 id="与逻辑（控制信号生成）"><a href="#与逻辑（控制信号生成）" class="headerlink" title="与逻辑（控制信号生成）"></a>与逻辑（控制信号生成）</h3><p>负责根据不同的指令信号生成控制信号,这里我把jal的PC+4也放到ALU里计算了，实际上更推荐单独走一条通路，简化控制信号设计  </p><table><thead><tr><th align="center">控制信号</th><th align="center">位数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RegDst</td><td align="center"><code>2</code></td><td align="center"><code>2&#39;b00 : rt</code> <br> <code>2&#39;b01 : rd</code> <br> <code>2&#39;b10 : $31</code></td></tr><tr><td align="center">RegWE</td><td align="center"><code>1</code></td><td align="center">GRF 写入使能信号</td></tr><tr><td align="center">ALUsrcA</td><td align="center"><code>2</code></td><td align="center"><code>2&#39;b00 : GRF[rs]</code> <br> <code>2&#39;b01 : pc值本身</code> <br> <code>2&#39;b10 : 0</code> <br> <code>2&#39;b11 : 0</code></td></tr><tr><td align="center">ALUsrcB</td><td align="center"><code>2</code></td><td align="center"><code>2&#39;b00 : GRF[rt]</code> <br> <code>2&#39;b01 : 经过EXT的32位立即数</code> <br> <code>2&#39;b10 : 4</code> <br> <code>2&#39;b11 : 0</code></td></tr><tr><td align="center">ALUop</td><td align="center"><code>4</code></td><td align="center">在ALU和ctrl中根据opcode和func生成</td></tr><tr><td align="center">DmWE</td><td align="center"><code>1</code></td><td align="center">DM 写入使能信号</td></tr><tr><td align="center">MemToReg</td><td align="center"><code>1</code></td><td align="center"><code>1&#39;b1 : DM[ReadAddress]</code> <br> <code>1&#39;b0 : ALUresult</code></td></tr><tr><td align="center">Branch</td><td align="center"><code>1</code></td><td align="center">beq 跳转信号</td></tr><tr><td align="center">Jump</td><td align="center"><code>1</code></td><td align="center">Jal 跳转信号</td></tr><tr><td align="center">EXTop</td><td align="center"><code>1</code></td><td align="center"><code>1&#39;b1 : 符号扩展</code> <br> <code>1&#39;b0 : 零扩展</code></td></tr><tr><td align="center">Jrsign</td><td align="center"><code>1</code></td><td align="center">Jr 信号</td></tr></tbody></table><h3 id="ALU-运算编码"><a href="#ALU-运算编码" class="headerlink" title="ALU 运算编码"></a>ALU 运算编码</h3><table><thead><tr><th align="center">ALUop</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center"><code>4&#39;b0000</code></td><td align="center">A + B</td></tr><tr><td align="center"><code>4&#39;b0001</code></td><td align="center">A - B</td></tr><tr><td align="center"><code>4&#39;b0010</code></td><td align="center">A | B</td></tr><tr><td align="center"><code>4&#39;b0011</code></td><td align="center">A &amp; B</td></tr><tr><td align="center"><code>4&#39;b0100</code></td><td align="center"><code>{ B[15:0], 16&#39;h0000 }</code></td></tr></tbody></table><h3 id="指令控制信号表"><a href="#指令控制信号表" class="headerlink" title="指令控制信号表"></a>指令控制信号表</h3><table><thead><tr><th align="center">指令</th><th align="center">RegDst</th><th align="center">RegWE</th><th align="center">ALUsrcA</th><th align="center">ALUsrcB</th><th align="center">ALUop</th><th align="center">DmWE</th><th align="center">MemToReg</th><th align="center">Branch</th><th align="center">Jump</th><th align="center">EXTop</th><th align="center">Jrsign</th></tr></thead><tbody><tr><td align="center"><code>add</code></td><td align="center"><code>01</code></td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>0000</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>sub</code></td><td align="center"><code>01</code></td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>0001</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>ori</code></td><td align="center"><code>00</code></td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>0010</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>lui</code></td><td align="center"><code>00</code></td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>0100</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>lw</code></td><td align="center"><code>00</code></td><td align="center"><code>1</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>0000</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>sw</code></td><td align="center"><code>00</code></td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>01</code></td><td align="center"><code>0000</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>beq</code></td><td align="center"><code>00</code></td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>0001</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>jal</code></td><td align="center"><code>10</code></td><td align="center"><code>1</code></td><td align="center"><code>01</code></td><td align="center"><code>10</code></td><td align="center"><code>0000</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr><tr><td align="center"><code>jr</code></td><td align="center"><code>01</code></td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>0000</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>1</code></td></tr><tr><td align="center"><code>nop</code></td><td align="center"><code>00</code></td><td align="center"><code>0</code></td><td align="center"><code>00</code></td><td align="center"><code>00</code></td><td align="center"><code>0000</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td><td align="center"><code>0</code></td></tr></tbody></table><p>一直到P4我都采用的是以指令为主的译码方式，即对于每一条指令，给出对于该指令的所有控制信号取值  </p><h2 id="P4课上"><a href="#P4课上" class="headerlink" title="P4课上"></a>P4课上</h2><p>太久远了没啥印象了，反正指令形式和P3基本一样，换成Verilog描述之后老老实实把RTL式子翻译成代码即可，比logisim舒服太多<br>P4还是单周期cpu，加新指令完全无需考虑前后指令的影响，只需要处理好每一条指令的数据通路即可  </p><p>贴上我的代码库，仅供参考<br><a href="https://github.com/Logarithm33/CO-2025/tree/main/P4">点击查看 GitHub 上的项目指南文件夹</a><br><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></p>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P3</title>
      <link href="/2025/12/01/BUAA-CO-P3/"/>
      <url>/2025/12/01/BUAA-CO-P3/</url>
      
        <content type="html"><![CDATA[<h1 id="P3-用Logisim搭建单周期cpu"><a href="#P3-用Logisim搭建单周期cpu" class="headerlink" title="P3 用Logisim搭建单周期cpu"></a>P3 用Logisim搭建单周期cpu</h1><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><p>处理器为32位单周期处理器，支持<code>add</code>,<code>sub</code>,<code>ori</code>,<code>lw</code>,<code>sw</code>,<code>beq</code>,<code>lui</code>,<code>nop</code>指令，其中<code>nop</code>为空指令，<code>add</code>,<code>sub</code>为无符号运算<br>根据要求，我应该设计以下几种模块</p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p><strong>IFU（取指单元）</strong><br>内部包含PC（程序计数器）用寄存器实现，地址范围0x00003000-0x00006FFFF<br>IM用ROM实现，容量为4096*32bit,地址从0开始</p><p>这里将PC中储存的地址转换为IM的地址，采用的是先PC-0x00003000，由于每条指令占四个字节所以右移2位（除以4）</p><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">位宽</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">reset</td><td align="center">I</td><td align="center">1</td><td align="center">异步复位信号</td></tr><tr><td align="center">clk</td><td align="center">I</td><td align="center">1</td><td align="center">时钟信号</td></tr><tr><td align="center">nextpc</td><td align="center">I</td><td align="center">32</td><td align="center">下一条指令所在地址</td></tr><tr><td align="center">pc</td><td align="center">O</td><td align="center">32</td><td align="center">目前指令所在地址</td></tr><tr><td align="center">Instr</td><td align="center">O</td><td align="center">32</td><td align="center">目前指令信号</td></tr></tbody></table><p><strong>GRF（通用寄存器堆）</strong><br>要求同P0课下完成的GRF,直接copy</p><p><strong>ALU（算数逻辑运算单元）</strong><br>要在该模块中实现32位加、减、或、与、比较大小的功能</p><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">位宽</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">I</td><td align="center">32</td><td align="center">运算数A</td></tr><tr><td align="center">B</td><td align="center">I</td><td align="center">32</td><td align="center">运算数B</td></tr><tr><td align="center">ALUop</td><td align="center">I</td><td align="center">4</td><td align="center">操作码</td></tr><tr><td align="center">result</td><td align="center">O</td><td align="center">32</td><td align="center">结果</td></tr><tr><td align="center">zero</td><td align="center">O</td><td align="center">1</td><td align="center">如果A&#x3D;B，置1</td></tr></tbody></table><table><thead><tr><th align="center">运算编码</th><th align="center">运算操作</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">A + B</td></tr><tr><td align="center">0001</td><td align="center">A - B</td></tr><tr><td align="center">0010</td><td align="center">A</td></tr><tr><td align="center">0011</td><td align="center">A &amp; B</td></tr><tr><td align="center">0100</td><td align="center">立刻将B传入的16位数传入A的高位</td></tr></tbody></table><p><strong>DM（数据储存器）</strong><br>使用RAM实现，容量为3072 × 32bit，应具有异步复位功能，地址采取先右移两位字对齐，然后截断低12位的方式寻址</p><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">位宽</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">WriteAddress</td><td align="center">I</td><td align="center">32</td><td align="center">在RAM中写入数据的地址</td></tr><tr><td align="center">WriteData</td><td align="center">I</td><td align="center">32</td><td align="center">写入的数据</td></tr><tr><td align="center">MemWE</td><td align="center">I</td><td align="center">1</td><td align="center">是否储存</td></tr><tr><td align="center">clk</td><td align="center">I</td><td align="center">1</td><td align="center">时钟信号</td></tr><tr><td align="center">reset</td><td align="center">I</td><td align="center">1</td><td align="center">异步复位信号</td></tr><tr><td align="center">ReadData</td><td align="center">O</td><td align="center">32</td><td align="center">读出的数据</td></tr></tbody></table><p><strong>EXT（扩展单元）</strong></p><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">位宽</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">in</td><td align="center">I</td><td align="center">16</td><td align="center">16位原数据</td></tr><tr><td align="center">EXTop</td><td align="center">I</td><td align="center">1</td><td align="center">为1则符号扩展，为0则零扩展</td></tr><tr><td align="center">out</td><td align="center">O</td><td align="center">32</td><td align="center">扩展后数据</td></tr></tbody></table><p><strong>NEXTPC（寻址单元）</strong><br>负责计算下一条指令的地址，目前分为两种情况，一种正常顺序执行PC &#x3D; PC + 4<br>另一种遇到beq指令 PC &#x3D; PC + 4 + (immediate16 &lt;&lt; 2)</p><table><thead><tr><th align="center">信号名</th><th align="center">方向</th><th align="center">位宽</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">PC</td><td align="center">I</td><td align="center">32</td><td align="center">当前指令地址</td></tr><tr><td align="center">immediate16</td><td align="center">I</td><td align="center">16</td><td align="center">beq指令相对偏移量</td></tr><tr><td align="center">OP</td><td align="center">I</td><td align="center">1</td><td align="center">为1则执行beq跳转，为0执行顺序跳转</td></tr><tr><td align="center">nextPC</td><td align="center">O</td><td align="center">32</td><td align="center">下一条指令地址</td></tr></tbody></table><p><strong>Controller(控制信号)</strong><br>由于nop为空指令，因此与控制信号无关<br>负责根据每条指令的OPcode生成对应的控制信号，将解码逻辑分为和逻辑和与逻辑<br>和逻辑负责根据OPcode译码为指定的指令信号</p><table><thead><tr><th align="center">OPcode</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">000000</td><td align="center">R型指令</td></tr><tr><td align="center">001101</td><td align="center">ori</td></tr><tr><td align="center">001111</td><td align="center">lui</td></tr><tr><td align="center">100011</td><td align="center">lw</td></tr><tr><td align="center">101011</td><td align="center">sw</td></tr><tr><td align="center">000100</td><td align="center">beq</td></tr></tbody></table><p>对r型指令，根据func译码为指定指令信号，并与OPcode输出信号用与门连接  </p><table><thead><tr><th align="center">func</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">100000</td><td align="center">add</td></tr><tr><td align="center">100010</td><td align="center">sub</td></tr></tbody></table><p>与逻辑负责根据不同的指令信号生成控制信号  </p><table><thead><tr><th align="center">控制信号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RegDst</td><td align="center">为1使用寄存器rd，为0使用寄存器rt</td></tr><tr><td align="center">RegWE</td><td align="center">GRF写入使能信号</td></tr><tr><td align="center">ALUsrc</td><td align="center">为1使用imme16经EXT扩展结果，为0使用寄存器读出数据ReadData</td></tr><tr><td align="center">ALUop</td><td align="center">根据opcode和func生成</td></tr><tr><td align="center">DmWE</td><td align="center">DM写入使能信号</td></tr><tr><td align="center">MemToReg</td><td align="center">为1将内存读出数据写入寄存器堆</td></tr><tr><td align="center">Branch</td><td align="center">为1代表beq指令，为0代表其他指令</td></tr></tbody></table><table><thead><tr><th align="center">指令</th><th align="center">RegDst</th><th align="center">RegWE</th><th align="center">ALUsrc</th><th align="center">ALUop</th><th align="center">DmWE</th><th align="center">MemToReg</th><th align="center">Branch</th></tr></thead><tbody><tr><td align="center">add</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0000</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">sub</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0001</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">ori</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0010</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">lui</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0100</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">lw</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0000</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">sw</td><td align="center">x</td><td align="center">0</td><td align="center">1</td><td align="center">0000</td><td align="center">1</td><td align="center">x</td><td align="center">0</td></tr><tr><td align="center">beq</td><td align="center">x</td><td align="center">0</td><td align="center">0</td><td align="center">x</td><td align="center">0</td><td align="center">x</td><td align="center">1</td></tr></tbody></table><h2 id="P3课上"><a href="#P3课上" class="headerlink" title="P3课上"></a>P3课上</h2><p>P3课上做了二周目，Logisim确实对我来说不好用<br>课上三题基本分为 <strong>只需要修改ALU和ctrl的计算类指令，修改npc的条件跳转指令（有可能含有条件写入），对dm读出数据进行处理的访存指令</strong><br>计算类指令没什么好说的，按照题目条件来就行了<br>条件跳转指令也比较公式，ctrl连出一条新信号和cmp的新信号用与门连接和npc连起来即可，我掉的小坑在条件写入如果不写入的话，grf的使能一定要是0，不然评测机会输出错误的写入信息<br>访存指令可能会涉及for循环，Logisim写for循环有点烦，我是看循环数不高直接枚举了，侥幸通过，从此不碰Logisim  </p><h2 id="课上碎碎念"><a href="#课上碎碎念" class="headerlink" title="课上碎碎念"></a>课上碎碎念</h2><p>第一次闯关上机就寄了，说实话心里确实没底，主要很快做出来一道之后在第二题直接卡到最后，下一次上机心里也没底能过，有点烦<br>卡关之后回来也对课下cpu做了很多优化，主要就是<strong>留出了ctrl中给新信号的预留位置</strong>，这样课上加指令不会在这些重复的部分浪费时间，这种预留思想也一直延续到了所有之后的上机，确实省了很多麻烦<br>后续的上机也证明了，P3卡关确实不是什么坏事，甚至能说因祸得福，给每次课下都留出了两周的充裕时间和中测保证课下正确性，反而对之后每次课上的上机更有信心了<br>总之核心思想就是，不挂P一定是好事，但挂P不一定是坏事，放宽心</p><p>贴上我的代码库，仅供参考<br><a href="https://github.com/Logarithm33/CO-2025/tree/main/P3">点击查看 GitHub 上的项目指南文件夹</a><br><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></p>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P2</title>
      <link href="/2025/12/01/BUAA-CO-P2/"/>
      <url>/2025/12/01/BUAA-CO-P2/</url>
      
        <content type="html"><![CDATA[<h1 id="P2-学习使用MIPS"><a href="#P2-学习使用MIPS" class="headerlink" title="P2 - 学习使用MIPS"></a>P2 - 学习使用MIPS</h1><p>P2的学习目标是学会使用MIPS汇编语言编写程序，或者说把c语言程序学会翻译成MIPS语言  </p><p>在后续的cpu迭代中，MIPS语言主要是用来写测试程序的，所以最基本最基本的事情就是学会写测试程序<br>这与P2课上考察的内容不能说毫无联系，只能说完全无关  </p><h2 id="P2课下"><a href="#P2课下" class="headerlink" title="P2课下"></a>P2课下</h2><p>P2课下四道题目</p><h3 id="P2-L0-matrix"><a href="#P2-L0-matrix" class="headerlink" title="P2_L0_matrix"></a>P2_L0_matrix</h3><p>第一题很简单的一个n阶矩阵乘法，复习一下矩阵的读写</p><h3 id="P2-L0-judge"><a href="#P2-L0-judge" class="headerlink" title="P2_L0_judge"></a>P2_L0_judge</h3><p>第二题判断是否是回文串，注意syscall的参数区别即可，$v0为8和12时采取的输入方式不同</p><h3 id="P2-L0-conv"><a href="#P2-L0-conv" class="headerlink" title="P2_L0_conv"></a>P2_L0_conv</h3><p>第三题输出初始矩阵经过卷积核计算后的卷积矩阵，除了计算方式和第一题不一样，其他基本都一样，如果涉及到多重循环，注意在内部的循环开始前要将循环变量清零</p><h3 id="P2-L0-full-1"><a href="#P2-L0-full-1" class="headerlink" title="P2_L0_full_1"></a>P2_L0_full_1</h3><p>第四题要求输出输入整数的全排列，复习了一下MIPS中函数调用的问题：<br>要注意在调用前后保护函数中寄存器的值，用出栈入栈的方式实现，注意的是应当在返回$ra后立刻出栈恢复寄存器，在调用函数前保护寄存器时也应当考虑到所有被修改的寄存器（这里的被修改指的不是在函数运算中被修改，而是在函数中充当常量的值，简单来判断，就是入栈代码后，所有被使用的寄存器都要入栈）</p><h2 id="P2课上"><a href="#P2课上" class="headerlink" title="P2课上"></a>P2课上</h2><p>和课下基本一致，题面都会给出相对应的c语言代码，做好翻译工作即可<br>就算没过对后续影响也不大，心态要调整好</p><p>贴上我的代码库，仅供参考<br><a href="https://github.com/Logarithm33/CO-2025/tree/main/P2">点击查看 GitHub 上的项目指南文件夹</a><br><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></p>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P1</title>
      <link href="/2025/12/01/BUAA-CO-P1/"/>
      <url>/2025/12/01/BUAA-CO-P1/</url>
      
        <content type="html"><![CDATA[<h1 id="P1-学习使用Verilog"><a href="#P1-学习使用Verilog" class="headerlink" title="P1 - 学习使用Verilog"></a>P1 - 学习使用Verilog</h1><p>P1的核心目的在于学会怎么使用Verilog对你要使用的模块进行建模，个人觉得是P2前最重要的一个P，毕竟后面当你开始迭代开发的时候用的也都是Verilog<br>学习Verilog过程中可能遇到的困难我从以下几个点整理了一下，基本包含了我和舍友的学习困难  </p><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>一步一步跟着官方教程走是没问题的。一步一步跟着官方教程走是没问题的。一步一步跟着官方教程走是没问题的。重要的事情说三遍  </p><p>ISE确实比较老的软件了，有的地方安装完重启一下电脑就好了，我第一次安装完没法仿真，第二天就行了，我也不知道我动了哪 </p><p>除非你电脑条件确实一般，不然我觉得虚拟机反而是更麻烦的选择  </p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>Verilog的语法和c语言的基本框架没啥区别，增加了一些硬件描述上的语法<br>比如非阻塞赋值和有符号数，这两个应该是Verilog新概念中理解稍微费点劲的概念<br>我个人的理解如下：<br>非阻塞赋值指的是不会因为当前的赋值阻碍指令的进行，比如  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &lt;= B </span><br><span class="line">B &lt;= C</span><br></pre></td></tr></table></figure><p>这两个语句事实上是同时执行的，将T0时刻的B和C分别赋值给A和B，而  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = B </span><br><span class="line">B = C</span><br></pre></td></tr></table></figure><p>这代表了先将B赋值给A，再将C赋值给B，可以理解为第一个语句阻塞了第二个语句的赋值，使这两句话有了顺序性</p><p>Verilog默认是无符号数运算，在对有符号数运算时需要加<code>$signed</code>符号，但这个符号又会隔绝位宽信息，导致需要位宽自动扩展的情况被自动截断<br>通解就是所有参与运算的变量常量全部加<code>$signed</code>，需要扩展时单加一个<code>$signed(64&#39;b0)</code>类似的位宽信息  </p><h3 id="波形调试"><a href="#波形调试" class="headerlink" title="波形调试"></a>波形调试</h3><p>这个习惯就好，不太直观上手有点乱，多调试几次就好了  </p><h2 id="P1课下"><a href="#P1课下" class="headerlink" title="P1课下"></a>P1课下</h2><p>P1课下六道题目，总体来看都比较简单，除了附加题都是实现某个电子元件  </p><h3 id="P1-L0-splitter"><a href="#P1-L0-splitter" class="headerlink" title="P1_L0_splitter"></a>P1_L0_splitter</h3><h3 id="P1-L0-ALU"><a href="#P1-L0-ALU" class="headerlink" title="P1_L0_ALU"></a>P1_L0_ALU</h3><h3 id="P1-L0-EXT"><a href="#P1-L0-EXT" class="headerlink" title="P1_L0_EXT"></a>P1_L0_EXT</h3><p>三道不涉及时序逻辑的基本电子元件<br>1.实现splitter，拼接一行解决<br>2.实现六种功能的ALU，前五种比较简单，算术右移可以直接使用$signed$ $($ $signed(a)$ $&gt;&gt;&gt;$ $b$ $)$，但这么按位数写一下没啥坏处，至少避免了不知名错误，譬如一开始WA时写的是$signed(a)$ $&gt;&gt;&gt;$ $b$，结果就是de不出bug<br>3.实现四种不同功能的移位器，都比较简单，注意补位数字的位数即可</p><h3 id="P1-L0-gray"><a href="#P1-L0-gray" class="headerlink" title="P1_L0_gray"></a>P1_L0_gray</h3><h3 id="P1-L0-EXPR"><a href="#P1-L0-EXPR" class="headerlink" title="P1_L0_EXPR"></a>P1_L0_EXPR</h3><p>两道时序电路状态机题，状态数比较少，我采取的是两段式状态机设计，输出逻辑用组合逻辑单独处理，状态转移和状态储存电路用时序逻辑处理，状态数较少，比较简单  </p><h3 id="P1-L1-BlockChecker"><a href="#P1-L1-BlockChecker" class="headerlink" title="P1_L1_BlockChecker"></a>P1_L1_BlockChecker</h3><p>附加题略微有点难思考，第一遍的时候脑子也没转过来，设计了两个状态机分别处理begin和end的输入，过了6&#x2F;9个数据点，de不出bug遂将两个状态机合二为一，共同处理输入序列，用不同的状态识别begin和end，虽然还没准确的把握到两种设计的区别，但从本质上讲，我认为一个输入最好不要在两个状态机里同时处理，容易导致状态的混乱，和输出的匹配逻辑也相应地提升了  </p><h2 id="P1课上"><a href="#P1课上" class="headerlink" title="P1课上"></a>P1课上</h2><p>P1课上三道题目，一道组合电路两道时序电路</p><h3 id="P1课上组合电路"><a href="#P1课上组合电路" class="headerlink" title="P1课上组合电路"></a>P1课上组合电路</h3><p>组合电路题目要求有点绕，梳理一下还是比较好写的，思路很简单但在考场上我实际写了40分钟+，de了半天bug最后发现与&amp;和或|写反了，纯纯闹麻了</p><h3 id="P1课上时序电路"><a href="#P1课上时序电路" class="headerlink" title="P1课上时序电路"></a>P1课上时序电路</h3><p>第一道时序电路较为简单，根据每个周期输入的op执行对应的指令即可，需要注意的点在于在单个周期内使用for循环时不能直接对寄存器进行非阻塞赋值，这样一个周期只会更新一次数值，我采用的方法是定义一个整型进行计数，然后非阻塞赋值给寄存器</p><p>贴上我的代码库，仅供参考<br><a href="https://github.com/Logarithm33/CO-2025/tree/main/P1">点击查看 GitHub 上的项目指南文件夹</a><br><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></p>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CO-P0</title>
      <link href="/2025/11/29/BUAA-CO-P0/"/>
      <url>/2025/11/29/BUAA-CO-P0/</url>
      
        <content type="html"><![CDATA[<h1 id="P0-学习使用Logisim"><a href="#P0-学习使用Logisim" class="headerlink" title="P0 - 学习使用Logisim"></a>P0 - 学习使用Logisim</h1><p>P0简单来说就是教你如何使用Logisim设计电路，在后续的实验课上硬性要求也只有P3需要使用，所以Logisim很多地方如果一知半解也不用太担心，p4以后纯看个人喜好，我过p3后是没碰过Logisim了<br>我个人也确实对Logisim用的很烂，因为我感觉不如verilog描述的那么直接，你想实现什么操作还要先思考需要什么元件怎么执行  </p><p>总的来讲，除了基本的门电路和元器件需要知道怎么用，教学组还喜欢考bit adder和bit checker这种不太常用的计算元件，知道是干啥的即可  </p><h2 id="P0课下"><a href="#P0课下" class="headerlink" title="P0课下"></a>P0课下</h2><p>P0课下五道题目</p><h3 id="P0-L0-CRC"><a href="#P0-L0-CRC" class="headerlink" title="P0_L0_CRC"></a>P0_L0_CRC</h3><p>本题是一个简化的CRC组合电路设计，原数据帧为8位除数为4位，主要考查了模二除法器的设计<br>子电路设计核心在于，当被除数首位为0时，直接跳过该轮除法（即余数为被除数）  </p><h3 id="P0-L0-GRF"><a href="#P0-L0-GRF" class="headerlink" title="P0_L0_GRF"></a>P0_L0_GRF</h3><p>本题是使用Logisim搭建一个GRF包含32个32位寄存器，包含异步复位，读数据和写数据三种功能<br>设计本身难度不大，注意写数据DMX的三态开关要开（防止不修改的寄存器报错）<br><strong>P3可以直接用的元件，好好设计能省点事</strong></p><h3 id="P0-L1-ftoi"><a href="#P0-L1-ftoi" class="headerlink" title="P0_L1_ftoi"></a>P0_L1_ftoi</h3><p>本题是组合电路部分的附加题，本人于美育课上在学长博客的帮助下奋力克服<br>本题要求输入一个16位半精度浮点数，输出他的整数部分，题干较为复杂，但题目要求有所简化<br>对于16位半精度浮点数，分为3个部分  </p><table><thead><tr><th align="center">Sign符号位</th><th align="center">Exponent指数位</th><th align="center">Mantissa尾数位</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">11111</td><td align="center">1111111111</td></tr></tbody></table><p>根据Exponent的数值不同，分为Normalized , Denormalized , Infinity , NaN<br>看上去类别很多，实际上后三种的数值一定在(-1,1)之中，换言之整数部分一定为0，因此只需要考虑Normalized一种情况即可<br>处理完整数部分的输出，最后再处理符号位，若符号位为1则对整数部分取反得答案  </p><h3 id="P0-L1-navigation"><a href="#P0-L1-navigation" class="headerlink" title="P0_L1_navigation"></a>P0_L1_navigation</h3><h3 id="P0-L0-FSM"><a href="#P0-L0-FSM" class="headerlink" title="P0_L0_FSM"></a>P0_L0_FSM</h3><p>两道时序电路设计题，均为有限状态机，第一题为Moore状态机第二题为Mealy状态机<br>区别不大，状态转移方程比较简单，第二题涉及到同步复位，用MUX实现同步复位<br>除此之位，在设计Mealy状态机时一定要注意输出电路涉及到的状态并非当前时间的状态，而是寄存器中的状态  </p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>就我个人而言，我认为Mealy状态机就是Moore状态机的状态转移和输出电路拆分开来，Moore状态机为了使输出和状态同步，用寄存器保存一周期的输出结果<br>换言之，<strong>Moore状态机状态转移电路&#x3D;Mealy状态机状态转移电路＋输出电路</strong><br><strong>在有限状态机输出时一定要注意输出的周期和要求匹不匹配！</strong></p><h2 id="P0课上"><a href="#P0课上" class="headerlink" title="P0课上"></a>P0课上</h2><p>P0 课上三道题目，两道时序电路一道组合电路</p><h3 id="P0课上时序电路"><a href="#P0课上时序电路" class="headerlink" title="P0课上时序电路"></a>P0课上时序电路</h3><p>一道Moore机一道Mealy机，考试在为寄存器赋初始值卡了一会，用counter赋值即可，注意不能赋值给寄存器，要直接赋值给pre数字</p><h3 id="P0课上组合电路"><a href="#P0课上组合电路" class="headerlink" title="P0课上组合电路"></a>P0课上组合电路</h3><p>没做出来吗的，一开始看题干有点蒙圈，稍微思考了一会有了大概思路，首先先判断初始楼层在哪，然后对其他三个楼层进行排序，每个初始楼层对应六种排序，共有四个初始楼层，共24种状态，按理直接Analyzed Circuit即可，结果硬是磨了一个多小时没debug成功，没找到哪个状态设的有问题，最后不了了之，反思下来在考场上有点蒙圈，耐心不太够，等题目出来复盘一下，很遗憾没能AC</p><p>课下十分钟复现完毕。<br>结果发现是comparater的模式没改，识别的是有符号数，考场上硬是没想到这一点。</p><p>P0难度不大，会写状态机会用元件基本就能过，没过也补不了了反正  </p><p>贴上我的代码库，仅供参考<br><a href="https://github.com/Logarithm33/CO-2025/tree/main/P0">点击查看 GitHub 上的项目指南文件夹</a><br><a href="https://github.com/Logarithm33">我的 GitHub 主页</a></p>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Launching My Hexo Blog</title>
      <link href="/2025/11/29/Launching-Hexo-Blog/"/>
      <url>/2025/11/29/Launching-Hexo-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Launching-Hexo-Blog-Setup-Blog"><a href="#Launching-Hexo-Blog-Setup-Blog" class="headerlink" title="Launching Hexo Blog: Setup Blog"></a>Launching Hexo Blog: Setup Blog</h1><p> 新博客的第一篇文章，记录一下从0开始使用<code>Hexo</code>搭建博客的完整配置和上线过程  </p><h2 id="1-GitHub-预准备"><a href="#1-GitHub-预准备" class="headerlink" title="1. GitHub 预准备"></a>1. GitHub 预准备</h2><p>我使用 GitHub Pages 作为博客的托管平台，感觉最简单的托管平台</p><ol><li><strong>创建仓库：</strong> 在 GitHub 上创建一个新的公开仓库，命名格式必须为 username.github.io，其中 <code>username</code> 是我自己的的 GitHub 用户名，如果搭建自己的博客换成自己用户名即可  </li><li><strong>配置分支：</strong> 使用 <code>main</code> 分支来托管我的静态文件（即 Hexo 生成的 public 目录内容）。</li></ol><h2 id="2-配置-Node-js-和-Git-环境"><a href="#2-配置-Node-js-和-Git-环境" class="headerlink" title="2. 配置 Node.js 和 Git 环境"></a>2. 配置 Node.js 和 Git 环境</h2><p>Hexo 依赖于 Node.js (用于运行 Hexo) 和 Git (用于部署到 GitHub)。<br>我电脑上预先都有，跳过这一步</p><h2 id="3-下载hexo环境"><a href="#3-下载hexo环境" class="headerlink" title="3. 下载hexo环境"></a>3. 下载hexo环境</h2><p>在本地选择&#x2F;my_blog作为我的博客根目录，在命令行中安装Hexo CLI  </p><ol><li><strong>安装 Hexo：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><strong>初始化博客：</strong> 在目标目录下初始化 Hexo 框架。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init my_blog</span><br><span class="line"><span class="built_in">cd</span> my_blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><strong>配置部署插件：</strong> 安装 Hexo 部署插件，用于自动化部署到 GitHub。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><strong>预览网站</strong> 在进入my_blog文件夹后打开命令行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Cleans the cache file and generated public folder</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Generates static files from source files</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Starts a local server for previewing the blog</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Deploys the generated static files to the remote site </span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-clone-butterfly"><a href="#4-clone-butterfly" class="headerlink" title="4. clone butterfly"></a>4. clone butterfly</h2><p>其实到这一步已经可以上线了，但为了美观和更多功能，使用Hexo下已经很成熟的<code>Butterfly</code>主题，直接将github上该项目克隆到<code>themes</code>文件夹中  </p><p>这里贴上 Butterfly 的链接 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 主题</a></p><ol><li><strong>下载主题：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure></li><li><strong>启用主题：</strong> 修改博客根目录下的主配置文件 <code>_config.yml</code>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="5-customization"><a href="#5-customization" class="headerlink" title="5. customization"></a>5. customization</h2><p>接下来就是个性化的部分，为了防止修改主题文件，我将themes中<code>_config.yml</code>复制到my_blog，重命名并将所有配置写在 <code>_config.butterfly.yml</code> 中</p><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>将图片放入&#x2F;source&#x2F;img文件夹后，<code>_config.butterfly.yml</code>中找到对应图片的设置，将路径修改为<code>/img/name.jpg/png</code>即可</p><h3 id="添加开始阅读按钮"><a href="#添加开始阅读按钮" class="headerlink" title="添加开始阅读按钮"></a>添加开始阅读按钮</h3><p>通过通过 <code>inject</code> 注入自定义的 CSS 和 JavaScript 代码，实现了悬浮于 Banner 下方的放大版“开始阅读”按钮</p><h3 id="添加搜索和导航"><a href="#添加搜索和导航" class="headerlink" title="添加搜索和导航"></a>添加搜索和导航</h3><p>安装了 <code>hexo-generator-search</code> 插件，并在主题配置中启用了 <code>local_search</code>，使访客能够快速查找文章</p><hr><p>第一篇博客随便写写，希望能帮到同样想要搭建自己博客记录学习轨迹的朋友<br>后续会上传更多跟日常学习有关的post</p><hr>]]></content>
      
      
      <categories>
          
          <category> Guides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
